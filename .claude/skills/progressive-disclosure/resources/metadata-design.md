# メタデータ設計ガイド

## 概要

スキルのYAML Frontmatter、特にdescriptionの設計は、スキル発動率とトークン効率に直接影響します。
このガイドでは、最適なメタデータ設計の原則と具体的な手法を提供します。

## YAML Frontmatter の構成要素

### 必須要素

#### name（スキル識別子）

**命名規則**: kebab-case

**パターン**:
- `[domain]-[topic]`: database-design, api-integration
- `[framework]-[feature]`: react-hooks, nextjs-routing
- `[tool]-[function]`: git-workflow, docker-optimization

**制約**:
- 最大64文字
- 英数字とハイフンのみ
- 先頭・末尾はハイフンNG

**判断基準**:
- [ ] ドメインが明確か？
- [ ] トピックが具体的か？
- [ ] 検索しやすいか？
- [ ] 他のスキルと区別できるか？

**例**:
```yaml
✅ 良い例:
- react-hooks
- database-schema-design
- api-error-handling

❌ 避けるべき:
- react（広すぎる）
- hooks（ドメイン不明）
- db-design-patterns-and-optimization（長すぎる）
```

---

#### description（最重要）

**構造**: 4つのセクション

**セクション1: 概要（1-2文）**
```yaml
[スキルの核心的機能を簡潔に記述]
[対象となる技術スタックや操作を明示]
```

**例**:
```yaml
React Hooks（useState、useEffect、useCallback、useMemo）の実装と最適化を専門とするスキル。
不要な再レンダリングの防止とパフォーマンス最適化を提供します。
```

**セクション2: 専門分野（2-4項目）**
```yaml
専門分野:
- [領域1]: [具体的な内容]
- [領域2]: [具体的な内容]
```

**例**:
```yaml
専門分野:
- 状態管理: useState、useReducer、状態の持ち上げ
- 副作用管理: useEffect、依存配列、クリーンアップ
- パフォーマンス最適化: useCallback、useMemo、React.memo
```

**セクション3: 使用タイミング（3-6項目）**
```yaml
使用タイミング:
- [具体的なシナリオ1]
- [具体的なシナリオ2]
- [具体的なシナリオ3]
```

**例**:
```yaml
使用タイミング:
- React Hooksを実装する時
- useEffectの依存配列を設計する時
- 不要な再レンダリングを防ぐ時
- カスタムフックを作成する時
```

**セクション4: プロアクティブ指示（オプション）**
```yaml
Use proactively when [自動発動条件].
```

**例**:
```yaml
Use proactively when implementing React components with hooks,
optimizing rendering performance, or creating custom hooks.
```

---

### オプション要素

#### version（バージョン番号）

**形式**: セマンティックバージョニング（major.minor.patch）

**バージョニング基準**:
```
major: 破壊的変更、構造の大幅変更
minor: 新しいリソース追加、機能拡張
patch: バグ修正、タイポ修正
```

**例**:
```yaml
version: 1.0.0  # 初版
version: 1.1.0  # リソース追加
version: 2.0.0  # 構造変更
```

---

## descriptionの最適化手法

### 手法1: トリガーキーワードの選定

**目的**: AIが確実に認識できるキーワードを含める

**キーワードタイプ**:

**技術名**:
- フレームワーク: React、Next.js、Vue
- ライブラリ: Drizzle、Zod、SWR
- 言語: TypeScript、Python

**操作**:
- 動詞: 設計、実装、最適化、テスト
- 名詞: スキーマ、API、コンポーネント

**概念**:
- パターン: Repository、Strategy、Observer
- 原則: SOLID、DRY、KISS

**選定基準**:
- [ ] ユーザーが使いそうなワードか？
- [ ] 一意性があるか（他スキルと区別できる）？
- [ ] 複数のバリエーションを含むか？

**例**:
```yaml
トピック: データベース設計

キーワード候補:
- 技術名: PostgreSQL, Drizzle ORM, SQL
- 操作: スキーマ設計, マイグレーション, クエリ最適化
- 概念: 正規化, インデックス, トランザクション

選定:
"PostgreSQL"（✅ 一意性高）
"スキーマ設計"（✅ 明確な操作）
"正規化"（✅ 重要概念）
```

---

### 手法2: 使用タイミングの具体化

**原則**: 抽象的なシナリオではなく、具体的な作業を記述

**抽象的（避けるべき）**:
```yaml
使用タイミング:
- 適切な時に使用
- 必要に応じて参照
```

**具体的（推奨）**:
```yaml
使用タイミング:
- データベーススキーマを設計する時
- Drizzleマイグレーションファイルを作成する時
- インデックスを追加・最適化する時
- クエリのパフォーマンスを改善する時
```

**具体化のテクニック**:
1. **動詞の使用**: 「〇〇する時」
2. **対象の明示**: 「何を」〇〇するか
3. **文脈の提供**: 「どのような状況で」

---

### 手法3: 除外条件の明示

**目的**: 誤発動を防ぎ、発動の精度を高める

**パターン**:
```yaml
使用タイミング:
- [シナリオ1]
- [シナリオ2]
- [シナリオ3]

ただし以下の場合は除く:
- [除外シナリオ1]
- [除外シナリオ2]
```

**例**:
```yaml
name: unit-testing
description: |
  Vitest による単体テストの作成とカバレッジ分析。

  使用タイミング:
  - 単体テストを作成する時
  - モック・スタブを実装する時
  - テストカバレッジを改善する時

  ただし以下の場合は除く:
  - E2Eテスト（playwright-testing スキルを使用）
  - APIテスト（api-testing スキルを使用）
```

---

## トークン効率の見積もり

### 見積もり式

```
メタデータ層: 約100トークン（固定）

SKILL.md本文: 行数 × 6トークン/行 ≈ 500行 × 6 = 3,000トークン

リソース層: Σ(各リソースの行数 × 6トークン/行)
例: 5ファイル × 400行 × 6 = 12,000トークン

総計: 100 + 3,000 + 12,000 = 15,100トークン
```

### 削減戦略

**戦略1: SKILL.mdの500行厳守**
```
500行超過の場合 → リソースに分割
削減効果: 超過分 × 6トークン/行
```

**戦略2: リソースの遅延読み込み**
```
全リソース一括ロード: 15,100トークン
必要なリソースのみ: 3,100トークン（1リソースのみの場合）
削減効果: 約80%
```

**戦略3: 冗長性の排除**
```
重複した説明: 削除
他スキルへの参照: リンクで代替
例の削減: 3個 → 2個
削減効果: 10-20%
```

---

## 参考文献

- **『Progressive Disclosure in User Interface Design』** Jakob Nielsen
- **『Don't Make Me Think』** Steve Krug著
- Scott Spence氏のスキル発動率研究
