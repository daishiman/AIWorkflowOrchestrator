# スキル発動最適化ガイド

## 概要

Claude Codeスキルの自動発動率は、descriptionの設計により大きく変動します。
適切な設計により、発動率を20%から84%に向上させることが可能です。

## 発動率の現状

### 基本統計（Scott Spence氏の研究より）

| 設計方式                          | 発動率  | 信頼性              |
| --------------------------------- | ------- | ------------------- |
| デフォルト（最小限のdescription） | ~20%    | ❌ 非常に低い       |
| シンプルな指示                    | ~50%    | ⚠️ コイン投げレベル |
| **強制評価プロトコル**            | **84%** | ✅ 高い一貫性       |
| LLM評価（複雑）                   | ~80%    | ⚠️ 変動が大きい     |

**推奨**: 強制評価プロトコルの使用

---

## 発動率向上の3つのアプローチ

### アプローチ1: メタデータ最適化

**原則**: descriptionを具体的かつキーワード豊富に設計

**実装**:

```yaml
❌ 不十分な例:
description: データベース設計に関するスキル。

問題点:
- 抽象的すぎる
- トリガーキーワードが少ない
- 使用タイミングが不明確

発動率: ~20%

✅ 最適化された例:
description: |
  データベーススキーマ、インデックス、トランザクション設計を専門とするスキル。
  Drizzle ORM、Turso（SQLite）、JSON活用による最適なDB設計を提供します。

  専門分野:
  - スキーマ設計: 正規化、Entity定義、外部キー制約
  - インデックス戦略: B-Tree、カーディナリティ分析
  - クエリ最適化: N+1問題回避、JOIN戦略、実行計画分析

  使用タイミング:
  - データベーススキーマを設計する時
  - インデックスを追加・最適化する時
  - クエリのパフォーマンスを改善する時
  - トランザクション境界を定義する時

  Use proactively when working with database schema, migrations, or query optimization.

改善点:
- 具体的な技術名（Drizzle、Turso、SQLite）
- 操作の明示（設計、最適化、定義）
- 具体的なシナリオ（4項目）
- プロアクティブ指示

発動率: ~75%
```

**キーワード選定の原則**:

- 技術名: 明示的に記載
- 操作: 動詞で具体化
- ドメイン: 対象領域を明確に

---

### アプローチ2: コミットメントメカニズム

**原則**: AIに明示的な評価と行動を強制する

**実装**: Hookによる強制評価プロトコル

**プロトコルの構造**:

```
Step 1 - EVALUATE:
各スキルについて、YES/NOを理由とともに明示的に表明

Step 2 - ACTIVATE:
YESと評価したスキルを必ず Skill() ツールで有効化

Step 3 - IMPLEMENT:
有効化が完了してから実装に進む
```

**なぜ効果的か**:

1. **明示的な評価**: AIが各スキルを意識的に検討する
2. **公開コミット**: YESと書き込むことで、行動が確定する
3. **順序の強制**: 評価→有効化→実装の流れを守らせる

**実装方法**:

```bash
# .claude/hooks/skill-forced-eval-hook.sh

#!/bin/bash
echo "
=== SKILL ACTIVATION PROTOCOL ===

Step 1 - EVALUATE: For each available skill, explicitly state YES/NO with reason
Step 2 - ACTIVATE: Use Skill() tool for all YES evaluations NOW
Step 3 - IMPLEMENT: Only proceed after activation

CRITICAL: You MUST evaluate and activate skills BEFORE implementation.
The evaluation is WORTHLESS unless you ACTIVATE the skills.
"
```

**設定**:

```json
{
  "hooks": {
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/skill-forced-eval-hook.sh"
          }
        ]
      }
    ]
  }
}
```

**発動率向上**: 50% → 84%

---

### アプローチ3: 発動パターンの設計

**3つの発動パターン**:

#### パターンA: 単一責任スキルパターン

**特徴**:

- 1つの明確なトピック
- プライマリキーワードの一致で発動
- 最も高い発動率

**設計**:

```yaml
name: react-hooks
description: |
  React Hooks（useState、useEffect、useCallback、useMemo）の実装と最適化。

  使用タイミング:
  - React Hooksを実装する時
  - useEffectの依存配列を設計する時
  - 不要な再レンダリングを防ぐ時
```

**発動率目標**: 90%以上

**適用条件**:

- [ ] トピックが単一か？
- [ ] トリガーが明確か？
- [ ] 他スキルと区別できるか？

---

#### パターンB: 階層的スキルパターン

**特徴**:

- 親スキルが広範なトリガーを持つ
- 子リソースが詳細な専門知識を提供
- 中程度の発動率

**設計**:

```yaml
# 親スキル
name: web-performance
description: |
  Webパフォーマンス最適化の包括的ガイド。

  使用タイミング:
  - ページ読み込みを高速化する時
  - レンダリング性能を改善する時
  - リソース最適化を行う時

# SKILL.md本文で子リソースへ誘導
## リソースへの参照
- 初期表示最適化: resources/initial-load.md
- ランタイム最適化: resources/runtime-performance.md
- リソース最適化: resources/resource-optimization.md
```

**発動率目標**: 70-80%

**適用条件**:

- [ ] 複数のサブトピックがあるか？
- [ ] 親スキルで包括的にカバーできるか？
- [ ] 子リソースへの参照が明確か？

---

#### パターンC: 協調的スキルパターン

**特徴**:

- 複数スキルの組み合わせが必要
- 各スキルが独立して発動判断
- 比較的低い発動率（複雑性による）

**設計**:

```yaml
# スキル1
name: api-client
description: API連携、HTTPリクエスト、エラーハンドリング
関連スキル: retry-strategies, authentication

# スキル2
name: retry-strategies
description: リトライロジック、指数バックオフ、サーキットブレーカー
関連スキル: api-client, error-handling

# 両方が協調して使用される
```

**発動率目標**: 60-70%

**適用条件**:

- [ ] 複数スキルの組み合わせが有益か？
- [ ] 各スキルが独立した価値を持つか？
- [ ] 相互参照が明確か？

---

## 発動率の測定と改善

### 測定方法

**ステップ1: テストプロンプトセットの作成**

```markdown
## react-hooks スキル - テストプロンプト

1. "useStateを使ってカウンターを実装して"
2. "useEffectでデータフェッチを実装"
3. "不要な再レンダリングを防ぐ方法は？"
4. "カスタムフックを作成したい"
5. "useCallbackとuseMemoの使い分けは？"

期待: すべてでreact-hooksが発動

実際の発動回数: **\_ / 5
発動率: \_\_**%
```

**ステップ2: 発動の記録**

```
プロンプト1: ✅ 発動
プロンプト2: ✅ 発動
プロンプト3: ❌ 未発動
プロンプト4: ✅ 発動
プロンプト5: ✅ 発動

発動率: 4/5 = 80%
```

**ステップ3: 未発動の分析**

```
プロンプト3で未発動:
- キーワード: "再レンダリング"
- descriptionに含まれていない
- 改善: "不要な再レンダリングを防ぐ時"を追加
```

**ステップ4: 改善と再測定**

```
description更新後:
発動率: 5/5 = 100%
```

---

## 改善サイクル

### 段階的な改善プロセス

**レベル1: 基本設計（発動率30-50%）**

```yaml
description: |
  [核心機能を1-2文で記述]

  使用タイミング:
  - [基本的なシナリオ1-2個]
```

**レベル2: トリガー強化（発動率50-70%）**

```yaml
description: |
  [核心機能 + 技術スタック明示]

  専門分野:
  - [領域1]
  - [領域2]

  使用タイミング:
  - [シナリオ3-4個、より具体的に]
```

**レベル3: 発動最適化（発動率70-85%）**

```yaml
description: |
  [核心機能 + 技術スタック + 具体的な操作]

  専門分野:
  - [領域1]: [詳細]
  - [領域2]: [詳細]

  使用タイミング:
  - [シナリオ5-6個、キーワード豊富]
  - [除外条件も明示]

  Use proactively when [明示的な発動条件].
```

**レベル4: コミットメント統合（発動率85%以上）**

```
上記 + Hookによる強制評価プロトコル
```

---

## トラブルシューティング

### 問題1: 発動率が50%未満

**原因**: description が抽象的すぎる

**解決策**:

1. 具体的な技術名を追加
2. 使用タイミングを3つ以上に増やす
3. キーワードを強化

### 問題2: 誤発動が多い

**原因**: トリガーが広すぎる

**解決策**:

1. 除外条件を明示
2. より具体的なシナリオに限定
3. 関連スキルとの境界を明確化

### 問題3: コミットメントメカニズムが機能しない

**原因**: Hookの設定ミスまたはスクリプトエラー

**解決策**:

1. スクリプトの実行権限を確認: `chmod +x`
2. settings.jsonのパス確認
3. 手動実行でテスト: `bash .claude/hooks/skill-forced-eval-hook.sh`

---

## 参考文献

- **『Nudge』** Richard Thaler, Cass Sunstein著
  - 選択アーキテクチャの設計

- スキル発動率研究: Scott Spence氏のブログ記事
