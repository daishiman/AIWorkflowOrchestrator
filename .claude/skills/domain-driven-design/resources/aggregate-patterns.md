# 集約パターンと境界設計

## 集約とは

集約（Aggregate）は、データ変更の単位として扱われるドメインオブジェクトのクラスタです。
各集約には、外部から参照される唯一のエンティティである「集約ルート」があります。

## 集約の設計原則

### 1. 小さな集約を維持

**原則**: 集約は必要最小限のオブジェクトのみを含むべき

**理由**:

- ロック競合の減少
- トランザクション時間の短縮
- メモリ使用量の削減
- 並行性の向上

**判断基準**:

- [ ] この要素は本当にトランザクション整合性が必要か？
- [ ] 結果整合性で十分ではないか？
- [ ] 集約が大きくなりすぎていないか？

### 2. 集約ルートの役割

**集約ルートの責務**:

- 集約全体の不変条件を保護
- 内部エンティティへのアクセス制御
- 外部からの唯一の参照ポイント

**設計ルール**:

- 外部は集約ルートのみを参照
- 内部エンティティへの直接参照は禁止
- 集約ルート経由で操作を実行

### 3. IDによる集約間参照

**原則**: 他の集約は直接参照せず、IDで参照

**理由**:

- 集約の独立性確保
- 遅延読み込みの実現
- 境界の明確化

**実装パターン**:

```
// 概念例
Order集約 {
  orderId: OrderId           // 自身のID
  customerId: CustomerId     // Customer集約へのID参照
  items: OrderItem[]         // 集約内のエンティティ
}

// ❌ 避けるべき: 直接参照
Order集約 {
  customer: Customer         // 他の集約への直接参照
}
```

### 4. 不変条件の境界

**定義**: 集約内で常に成立すべきビジネスルール

**例**:

- 注文の合計金額は明細金額の合計と一致
- 在庫数量は0以上
- ワークフローのステップは順序通り

**設計ステップ**:

1. 不変条件をすべて列挙
2. 同時に保証すべき条件をグループ化
3. グループを集約の候補とする

## 集約境界の決定方法

### ステップ1: 不変条件の特定

```
例: 注文システム

不変条件:
1. 注文合計 = Σ明細金額
2. 注文ステータスは有効な遷移のみ
3. 顧客は有効なメンバーである（結果整合性でOK）
4. 商品の在庫は0以上（別の集約）
```

### ステップ2: 同時整合性の要否判断

| 条件                 | 同時整合性 | 結果整合性 |
| -------------------- | ---------- | ---------- |
| 注文合計 = Σ明細金額 | ✓          |            |
| 注文ステータス遷移   | ✓          |            |
| 顧客の有効性         |            | ✓          |
| 商品在庫             |            | ✓          |

### ステップ3: 集約の定義

```
Order集約 {
  ルート: Order
  内部: OrderItem[]
  参照: customerId, productId
}

Customer集約 {
  ルート: Customer
  内部: CustomerProfile
}

Product集約 {
  ルート: Product
  内部: StockQuantity
}
```

## 集約間の連携パターン

### パターン1: ドメインイベント

**用途**: 集約間の結果整合性を実現

**フロー**:

1. 集約Aで操作実行
2. ドメインイベントを発行
3. イベントハンドラで集約Bを更新

**例**:

```
注文完了 → OrderCompletedイベント発行
         → 在庫を減少（別トランザクション）
         → ポイント付与（別トランザクション）
```

### パターン2: アプリケーションサービスでの調整

**用途**: 複数集約の操作を調整

**原則**:

- 1つのトランザクションで1つの集約のみ変更
- 複数集約の変更は複数トランザクションで
- 失敗時の補償処理を設計

### パターン3: サガパターン

**用途**: 長時間トランザクションの管理

**種類**:

- コレオグラフィ: イベント駆動の分散協調
- オーケストレーション: 中央コーディネーターによる制御

## アンチパターン

### 1. 巨大な集約

**症状**: 多くのエンティティを含む大きな集約

**問題**:

- ロック競合
- パフォーマンス低下
- 変更の影響範囲が広い

**解決策**:

- 結果整合性の活用
- 集約の分割
- IDによる参照

### 2. 集約間の直接参照

**症状**: 集約が他の集約を直接持つ

**問題**:

- 境界の曖昧化
- 読み込みの複雑化
- 変更の影響伝播

**解決策**:

- IDによる参照に変更
- 必要時に別途取得

### 3. 不変条件の無視

**症状**: 集約ルートを経由せずに内部を変更

**問題**:

- 不変条件の破綻
- データ整合性の喪失

**解決策**:

- 内部エンティティへのアクセス制限
- 集約ルート経由の操作強制

## チェックリスト

### 集約設計チェック

- [ ] 集約は十分に小さいか？
- [ ] 集約ルートが明確に特定されているか？
- [ ] 不変条件がすべて列挙されているか？
- [ ] 他の集約への参照はIDのみか？
- [ ] 集約間の結果整合性が設計されているか？
- [ ] 内部エンティティへの直接アクセスは防止されているか？
- [ ] トランザクション境界が明確か？
