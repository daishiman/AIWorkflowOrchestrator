# エンティティ設計ガイド

## エンティティとは

エンティティとは、ライフサイクルを通じて一意な識別子（ID）によって識別されるドメインオブジェクトです。
属性が変化しても、同一性は保たれます。

## エンティティの識別基準

### 質問チェックリスト

| 質問                                       | Yesの場合  | Noの場合         |
| ------------------------------------------ | ---------- | ---------------- |
| このオブジェクトはライフサイクルを持つか？ | Entity候補 | Value Object候補 |
| 属性が変化しても同一と見なすか？           | Entity     | Value Object     |
| 一意な識別子が必要か？                     | Entity     | Value Object     |
| 履歴追跡が必要か？                         | Entity     | Value Object     |

### 具体例

**エンティティの例**:

- `User`: 名前やメールが変わっても同一ユーザー
- `Order`: 注文状態が変化しても同一注文
- `Workflow`: 実行状態が変化しても同一ワークフロー

**値オブジェクトの例**:

- `Email`: メールアドレスの値そのものが重要
- `Money`: 金額と通貨の組み合わせ
- `Address`: 住所の各要素の組み合わせ

## エンティティ設計のステップ

### Step 1: 識別子の設計

**識別子の種類**:

- **UUID**: 分散システムに適した一意性
- **シーケンシャルID**: データベース効率性
- **ナチュラルキー**: ビジネス上の一意性（例: 社員番号）

**設計原則**:

- 識別子は不変であること
- 値オブジェクトとして定義（型安全性確保）
- 外部に露出する場合はtoString()を提供

```typescript
// 概念例: 識別子の値オブジェクト化
// UserId は string ではなく専用の型として定義
// - 不変性を保証
// - 型レベルでの区別（UserIdとOrderIdを混同しない）
// - バリデーションをコンストラクタに集約
```

### Step 2: 属性の設計

**原則**:

- プリミティブ型ではなく値オブジェクトを使用
- 必須属性と任意属性を明確に区別
- 属性のアクセス制御を適切に設定

**判断基準**:

- [ ] プリミティブ型執着を避けているか？
- [ ] 属性の変更は適切に制御されているか？
- [ ] 必須/任意が明確か？

### Step 3: 不変条件の定義

**不変条件（Invariants）とは**:
エンティティが常に満たすべきビジネスルール

**例**:

- 注文金額は0以上
- ワークフローのステータス遷移は特定のパターンのみ
- ユーザーは常に有効なメールアドレスを持つ

**実装原則**:

- コンストラクタで初期状態の検証
- 状態変更メソッドで遷移の検証
- private setterで直接変更を防止

### Step 4: 状態遷移の設計

**状態機械アプローチ**:

1. すべての有効な状態を列挙
2. 許可される遷移パスを定義
3. 遷移メソッドで前提条件をチェック
4. 不正な遷移を例外でブロック

**設計パターン**:

```
状態遷移図の例:
PENDING → PROCESSING → COMPLETED
                    → FAILED

遷移ルール:
- PENDING からのみ PROCESSING に遷移可能
- COMPLETED/FAILED は終端状態
- 逆方向の遷移は禁止
```

### Step 5: ビジネスメソッドの設計

**原則**:

- Tell, Don't Ask: 状態を問い合わせてから操作するのではなく、操作を依頼
- コマンドクエリ分離: 状態変更と状態取得を分離
- 意図を表す名前: `setStatus()` ではなく `complete()`, `fail()`

**判断基準**:

- [ ] メソッド名がドメイン用語を使用しているか？
- [ ] ビジネスロジックがエンティティ内にカプセル化されているか？
- [ ] 外部からの不正な状態変更が防止されているか？

## アンチパターン

### 1. 貧血ドメインモデル

**症状**: getter/setterのみで、ビジネスロジックがない

**問題**: ロジックがサービス層に散在し、凝集度が低下

**解決策**: ビジネスロジックをエンティティ内に移動

### 2. プリミティブ型執着

**症状**: string, number, booleanを多用

**問題**: 型安全性の欠如、バリデーション漏れ

**解決策**: 値オブジェクトを定義

### 3. 不変条件の漏れ

**症状**: setterで自由に値を変更可能

**問題**: 不正な状態のエンティティが生成される

**解決策**: private setterと検証メソッドの使用

## チェックリスト

### エンティティ設計完了チェック

- [ ] 一意な識別子が定義されているか？
- [ ] 識別子は不変で、値オブジェクトとして実装されているか？
- [ ] プリミティブ型ではなく値オブジェクトを使用しているか？
- [ ] 不変条件が明確に定義され、常に保護されているか？
- [ ] 状態遷移のルールが実装されているか？
- [ ] ビジネスロジックがエンティティ内にカプセル化されているか？
- [ ] メソッド名がドメイン用語を使用しているか？
- [ ] 外部からの不正な状態変更が防止されているか？
