# 曖昧性パターン検出・除去ガイド

## 概要

このドキュメントは、要件における5つの曖昧性パターンを体系的に検出・除去するための実践ガイドです。
カール・ウィーガーズの要求工学理論に基づき、各パターンの検出手法、除去テクニック、実践例を提供します。

## 5つの曖昧性パターン

### パターン1: 量的曖昧性（Quantitative Ambiguity）

#### 定義と特徴

数値や量を表す表現が具体的でない状態。
「速い」「多い」「頻繁に」など、測定不可能な量的表現が使用されている。

#### 検出キーワード一覧

**速度・時間系**:
- 高速、速い、遅い、即座に、瞬時に、すぐに
- リアルタイム、ほぼリアルタイム
- 短時間、長時間、一定時間

**量・規模系**:
- 多い、少ない、大量、少量、適量
- 大きい、小さい、巨大、微小
- 軽い、重い、膨大

**頻度系**:
- 頻繁に、たまに、しばしば、時々
- 定期的に、不定期に、随時
- 常に、めったに、まれに

**性能系**:
- 高性能、低性能、高効率、低効率
- 高速処理、大容量、高スループット

#### 除去手法

**1. 具体的な数値と単位を要求**

```markdown
Before（曖昧）:
「システムは高速に応答する」

After（明確）:
「システムは95パーセンタイルで200ms以内に応答する」

除去プロセス:
1. 「高速」とは何秒/ミリ秒か？ → 200ms
2. すべてのケースか？ → 95パーセンタイル
3. どこで測定するか？ → サーバー側
4. どの操作か？ → API応答時間
```

**2. パーセンタイルと分布を明示**

```markdown
Before（曖昧）:
「ほとんどのリクエストは速い」

After（明確）:
「リクエスト応答時間:
 - 95パーセンタイル: <500ms
 - 99パーセンタイル: <1s
 - 99.9パーセンタイル: <3s
 測定方法: New Relicのサーバー側計測」

除去プロセス:
1. 「ほとんど」の定義 → 95%以上
2. 「速い」の定義 → <500ms
3. 例外ケースの扱い → 99パーセンタイルで<1s
4. 測定方法の明示 → New Relic
```

**3. 範囲と条件を明示**

```markdown
Before（曖昧）:
「大量のユーザーが同時にアクセスできる」

After（明確）:
「同時接続ユーザー数:
 - 最小保証: 1,000人
 - 目標: 10,000人
 - ピーク時想定: 50,000人（3ヶ月後）
 負荷条件: 1ユーザーあたり毎分3リクエスト」

除去プロセス:
1. 「大量」の具体的な数 → 10,000人
2. 最小値と目標値の区別 → 最小1,000、目標10,000
3. 将来の拡張性 → 50,000人（3ヶ月後）
4. 条件の明示 → 毎分3リクエスト/ユーザー
```

**4. ベンチマークと比較基準を使用**

```markdown
Before（曖昧）:
「競合サービスより速い」

After（明確）:
「ベンチマーク:
 - 現行システム: 800ms → 目標: <200ms（4倍高速化）
 - 競合A（市場リーダー）: 300ms → 目標: <200ms（1.5倍高速）
 - 競合B: 500ms → 目標: <200ms（2.5倍高速）
 測定条件: 同一ハードウェア、同一データセット」

除去プロセス:
1. 比較対象の明示 → 競合A、B
2. 現状の数値化 → 800ms、300ms、500ms
3. 目標の数値化 → <200ms
4. 測定条件の統一 → 同一環境
```

#### 実践例

**例1: パフォーマンス要件**

```markdown
Before:
「データベースクエリは高速に実行される」

分析:
- 曖昧なキーワード: 「高速」
- パターン: 量的曖昧性（速度系）
- 不足情報: 時間、測定方法、条件

質問設計:
Q1: 「高速」とは具体的に何ミリ秒ですか？
Q2: すべてのクエリで同じ基準ですか？
Q3: どこで測定しますか？（アプリケーション側？DB側？）
Q4: データ量による変動はありますか？

回答例:
A1: 95パーセンタイルで<50ms
A2: SELECT文のみ。INSERT/UPDATEは別基準
A3: データベース側で測定（EXPLAIN ANALYZEの実測値）
A4: テーブルサイズ100万レコードを前提

After:
「データベースクエリのパフォーマンス要件:

 SELECT文:
 - 95パーセンタイル: <50ms
 - 99パーセンタイル: <100ms
 - 条件: テーブルサイズ100万レコード

 INSERT/UPDATE/DELETE文:
 - 95パーセンタイル: <200ms
 - 99パーセンタイル: <500ms

 測定方法:
 - PostgreSQL EXPLAIN ANALYZEの実測値
 - データベース側での計測（ネットワーク遅延は含まない）

 例外:
 - バッチ処理: 1時間以内の完了を許容
 - レポート生成: 5分以内の完了を許容」
```

**例2: データ量の要件**

```markdown
Before:
「システムは大量のデータを処理できる」

分析:
- 曖昧なキーワード: 「大量」「処理」
- パターン: 量的曖昧性（量・規模系）
- 不足情報: データ量、処理内容、時間

質問設計:
Q1: 「大量」とは具体的に何レコードですか？
Q2: 「処理」とは何を指しますか？（読み取り？書き込み？計算？）
Q3: どのくらいの時間で処理しますか？
Q4: データ増加率の想定は？

回答例:
A1: 初期: 100万レコード、3年後: 1億レコード
A2: CSV一括インポート、データ変換、検証
A3: 100万レコードを10分以内
A4: 年間30%増加を想定

After:
「データ処理能力の要件:

 初期要件（リリース時）:
 - データ量: 100万レコード
 - 処理内容: CSVインポート → データ変換 → バリデーション
 - 処理時間: <10分（100万レコード）
 - スループット: 1,600レコード/秒以上

 拡張性要件（3年後）:
 - データ量: 1億レコード
 - 処理時間: <16時間（夜間バッチ処理）
 - スループット: 同等（1,600レコード/秒）

 成長予測:
 - 年間データ増加率: 30%
 - Year 1: 130万レコード
 - Year 2: 170万レコード
 - Year 3: 220万レコード → スケーリング対応

 測定条件:
 - ハードウェア: AWS EC2 t3.xlarge相当
 - データ特性: 1レコード平均50カラム、2KB」
```

### パターン2: 質的曖昧性（Qualitative Ambiguity）

#### 定義と特徴

品質や状態を表す形容詞が測定不可能な状態。
「使いやすい」「適切に」など、主観的で検証できない表現が使用されている。

#### 検出キーワード一覧

**ユーザビリティ系**:
- 使いやすい、分かりやすい、簡単、直感的
- 親しみやすい、覚えやすい、学びやすい
- 快適、スムーズ、自然

**品質系**:
- 適切に、正しく、うまく、きちんと
- 十分、満足、良好、優れた
- 信頼性の高い、安定した、堅牢

**効率系**:
- 効率的、効果的、最適、合理的
- 無駄がない、スマート、洗練された

**柔軟性系**:
- 柔軟な、拡張可能な、カスタマイズ可能
- 汎用的、応用が利く

#### 除去手法

**1. 測定可能な基準を定義**

```markdown
Before（曖昧）:
「使いやすいUI」

After（明確）:
「ユーザビリティ基準:

 学習容易性:
 - 新規ユーザーが5分以内に基本操作（ログイン、検索、閲覧）を習得
 - チュートリアルなしで80%のユーザーが完了

 効率性:
 - 主要タスクは3クリック以内で完了
 - キーボードショートカット10個以上

 エラー回復:
 - 入力エラー時に具体的な修正方法を提示
 - 削除操作は確認ダイアログで取り消し可能

 測定方法:
 - ユーザビリティテスト（被験者5名以上）
 - SUS（System Usability Scale）スコア70点以上」

除去プロセス:
1. 「使いやすい」の具体化 → 学習容易性、効率性、エラー回復
2. 数値基準の設定 → 5分、3クリック、80%
3. 測定方法の明示 → ユーザビリティテスト、SUSスコア
```

**2. ユーザー行動を基準にする**

```markdown
Before（曖昧）:
「直感的な操作」

After（明確）:
「直感性の検証基準:

 初回利用時（チュートリアルなし）:
 - タスクA（商品検索）: 80%のユーザーが3分以内に成功
 - タスクB（カート追加）: 90%のユーザーが1分以内に成功
 - タスクC（決済）: 70%のユーザーがサポートなしで完了

 操作の発見可能性:
 - 主要機能のボタンが10秒以内に発見される
 - ヘルプを見ずに90%のユーザーが基本操作を実行

 メンタルモデルの一致:
 - 既存ECサイト（Amazon、楽天）と同様の操作フロー
 - 業界標準のアイコン、用語を使用」

除去プロセス:
1. タスクの明確化 → タスクA、B、C
2. 成功率の数値化 → 80%、90%、70%
3. 時間制約の設定 → 3分、1分
4. 比較基準の明示 → Amazon、楽天
```

**3. 具体的なシナリオを記述**

```markdown
Before（曖昧）:
「柔軟な設定」

After（明確）:
「設定のカスタマイズ範囲:

 管理者が変更可能な項目:
 - ブランディング: ロゴ（PNG/SVG、最大200KB）、配色（6パターンから選択）
 - メニュー構成: 最大10項目、ドラッグ&ドロップで並び替え
 - 通知設定: Email/Slack/Webhook、最大5つの通知ルール

 一般ユーザーが変更可能な項目:
 - 表示設定: テーマ（ライト/ダーク）、言語（日本語/英語）
 - 通知設定: 個人の通知ON/OFF、受信時間帯

 変更不可の項目:
 - セキュリティポリシー（管理者でも変更不可）
 - データ保存期間（コンプライアンス要件）

 設定の反映:
 - ブランディング: 保存後即座に反映
 - メニュー構成: 保存後、全ユーザーに5分以内に反映
 - 通知設定: 次回通知から反映」

除去プロセス:
1. 「柔軟」の具体化 → カスタマイズ可能な項目の列挙
2. 権限の明示 → 管理者、一般ユーザー
3. 制約の明示 → 変更不可の項目
4. 動作の明示 → 反映タイミング
```

**4. 品質指標で定量化**

```markdown
Before（曖昧）:
「安定したシステム」

After（明確）:
「システム安定性の要件:

 可用性:
 - 稼働率: 99.9%以上（月間ダウンタイム<43分）
 - 計画メンテナンス: 月1回、日曜日午前2-6時

 信頼性:
 - MTBF（平均故障間隔）: 720時間以上（30日）
 - MTTR（平均復旧時間）: 1時間以内

 エラー率:
 - サーバーエラー（5xx）: 0.01%以下
 - クライアントエラー（4xx）: 1%以下

 データ整合性:
 - データ損失: ゼロトレランス
 - バックアップ: 1時間ごと、30日間保存
 - 復旧テスト: 四半期ごとに実施

 測定方法:
 - 監視ツール: New Relic、Datadog
 - アラート: 稼働率が99.9%を下回った場合に通知
 - レポート: 月次で可用性レポートを作成」

除去プロセス:
1. 「安定」の多面的定義 → 可用性、信頼性、エラー率、データ整合性
2. 具体的な数値目標 → 99.9%、720時間、0.01%
3. 測定とモニタリング → New Relic、月次レポート
```

#### 実践例

**例1: セキュリティ要件**

```markdown
Before:
「システムは適切なセキュリティ対策を実施する」

分析:
- 曖昧なキーワード: 「適切な」
- パターン: 質的曖昧性（品質系）
- 不足情報: 具体的な対策、基準、測定方法

質問設計:
Q1: 「適切な」とは、どの標準に準拠しますか？
Q2: 具体的にどのようなセキュリティ対策ですか？
Q3: 優先度の高い脅威は何ですか？
Q4: セキュリティレベルをどう測定しますか？

回答例:
A1: OWASP Top 10に準拠
A2: 認証、認可、暗号化、監査ログ
A3: SQLインジェクション、XSS、CSRF
A4: 脆弱性スキャン、ペネトレーションテスト

After:
「セキュリティ要件:

 準拠標準:
 - OWASP Top 10（2021版）の全項目に対応
 - ISO/IEC 27001のセキュリティ管理策を適用

 認証・認可:
 - 認証: JWT（有効期限1時間）、リフレッシュトークン（30日）
 - 認可: RBAC、ロール定義3種（システム管理者、組織管理者、一般）
 - MFA: 管理者ロールは必須、一般ユーザーは任意

 通信の暗号化:
 - すべてのHTTP通信: TLS 1.2以上
 - データベース接続: SSL/TLS
 - 暗号化アルゴリズム: AES-256（データ）、RSA-2048（鍵交換）

 パスワードポリシー:
 - 最小8文字、大文字・小文字・数字・記号を各1文字以上
 - bcryptでハッシュ化（cost factor=12）
 - パスワード履歴: 過去5回分を保存、再利用禁止

 脆弱性対策:
 - SQLインジェクション: プリペアドステートメントを使用
 - XSS: 入力値のエスケープ、CSPヘッダー
 - CSRF: トークン検証、SameSite Cookie

 監査ログ:
 - 記録対象: ログイン試行、データ変更操作、権限変更
 - 保存期間: 1年間、暗号化して保存
 - アクセス: システム管理者のみ閲覧可能

 検証方法:
 - 脆弱性スキャン: OWASP ZAP、四半期ごと
 - ペネトレーションテスト: 外部業者、年1回
 - コードレビュー: セキュリティチェックリストで全PRをレビュー」
```

### パターン3: 範囲の曖昧性（Scope Ambiguity）

#### 定義と特徴

対象範囲が「など」「等」で省略され、完全に列挙されていない状態。
暗黙的な前提や、省略された要素が後で問題になる。

#### 検出キーワード一覧

**省略系**:
- など、等、その他、他
- 例えば、たとえば
- 〜をはじめとする、〜を含む

**不定系**:
- いくつかの、さまざまな、種々の
- 複数の、多数の、各種
- 一部の、一定の

**代表系**:
- 主な、主要な、代表的な
- 典型的な、一般的な、基本的な

#### 除去手法

**1. 完全な列挙**

```markdown
Before（曖昧）:
「画像ファイルなど」

After（明確）:
「サポートするファイル形式:
 - 画像: .jpg, .jpeg, .png, .gif, .webp, .svg
 - ファイルサイズ: 各ファイル最大10MB
 - 解像度: 最大8192x8192px
 - 合計容量: ユーザーあたり1GB

 非サポート:
 - 動画: .mp4, .mov, .avi等（将来対応予定）
 - RAW画像: .cr2, .nef等（現バージョンでは非対応）
 - 実行ファイル: .exe, .sh, .bat（セキュリティリスクのため禁止）」

除去プロセス:
1. 「など」の中身を列挙 → 6形式を明示
2. 制約条件の明示 → ファイルサイズ、解像度
3. 非サポートの明示 → 動画、RAW、実行ファイル
4. 理由の明示 → セキュリティリスク
```

**2. パターンの明示**

```markdown
Before（曖昧）:
「各種レポート」

After（明確）:
「レポート機能の種類:

 定期レポート:
 - 日次レポート: 毎日午前6時に自動生成、PDF形式
 - 週次レポート: 毎週月曜日午前6時、PDF + Excel形式
 - 月次レポート: 毎月1日午前6時、PDF + Excel + PowerPoint形式

 カスタムレポート:
 - 期間指定: 開始日〜終了日（最大1年間）
 - フィルタ条件: 部門、商品カテゴリ、ステータス
 - 出力形式: PDF、Excel、CSV（ユーザーが選択）
 - 生成時間: 即時（データ量により1-5分）

 テンプレート数:
 - 標準テンプレート: 10種類（売上、在庫、顧客等）
 - カスタムテンプレート: ユーザーが作成可能（最大20個）

 配信方法:
 - Email: 指定したメールアドレスに送信（最大10件）
 - ダウンロード: 管理画面からダウンロード（30日間保存）
 - API: RESTful APIで取得可能」

除去プロセス:
1. レポートの種類を分類 → 定期、カスタム
2. 各種類の詳細を明示 → 頻度、形式、生成時間
3. 上限の明示 → 最大1年間、最大20個
```

**3. 除外項目の明示**

```markdown
Before（曖昧）:
「一般的なファイル形式をサポート」

After（明確）:
「ファイル形式のサポート状況:

 サポート対象:

 ドキュメント:
 - Microsoft Office: .docx, .xlsx, .pptx（Office 2007以降）
 - PDF: .pdf（PDF 1.4以降）
 - テキスト: .txt, .csv, .json, .xml

 画像:
 - 一般形式: .jpg, .png, .gif, .webp
 - ベクター: .svg

 圧縮ファイル:
 - .zip, .tar.gz（パスワード保護なしのみ）

 非サポート（明示的に拒否）:

 セキュリティリスク:
 - 実行ファイル: .exe, .sh, .bat, .cmd
 - マクロ付きOffice: .docm, .xlsm, .pptm
 - スクリプト: .js, .vbs, .ps1

 技術的制約:
 - 古いOffice形式: .doc, .xls, .ppt（Office 2003以前）
 - CADファイル: .dwg, .dxf
 - 動画: .mp4, .mov, .avi（別モジュールで対応予定）

 制限事項:
 - ファイルサイズ: 各ファイル最大50MB
 - パスワード保護: サポート外
 - 暗号化ファイル: サポート外」

除去プロセス:
1. サポート対象の完全列挙 → 3カテゴリ、11形式
2. 非サポートの理由別分類 → セキュリティ、技術的制約
3. 制限事項の明示 → ファイルサイズ、パスワード保護
```

**4. 数量と上限の明示**

```markdown
Before（曖昧）:
「複数の通知方法」

After（明確）:
「通知機能の仕様:

 通知チャネル（同時設定可能数: 5つまで）:
 1. Email: SMTPまたはSendGrid経由、宛先最大10件
 2. Slack: Webhook URL、チャネル最大3つ
 3. Microsoft Teams: Webhook URL、チャネル最大3つ
 4. Webhook: カスタムURL、最大5つ
 5. SMS: Twilio経由、電話番号最大5件（オプション機能）

 通知ルール（最大10ルール/ユーザー）:
 - トリガー条件: イベント種別、優先度、タグ
 - フィルタ: AND/OR条件で組み合わせ可能
 - 通知頻度: 即時/5分間隔/1時間間隔/日次

 通知内容のカスタマイズ:
 - 件名: テンプレート変数を使用（最大100文字）
 - 本文: Markdown形式（最大1000文字）
 - 添付: なし（セキュリティ上の理由）

 制限事項:
 - 同一イベントの重複通知防止: 5分間のクールダウン
 - 1日の通知上限: 100件/ユーザー
 - 通知失敗時のリトライ: 3回まで、指数バックオフ」

除去プロセス:
1. 「複数」の具体的な数 → 5チャネル、10ルール
2. 各チャネルの上限 → 10件、3つ、5つ
3. カスタマイズの範囲 → 件名100文字、本文1000文字
4. 制限事項の明示 → クールダウン、上限、リトライ
```

#### 実践例

**例1: 対応ブラウザ**

```markdown
Before:
「主要なブラウザに対応」

分析:
- 曖昧なキーワード: 「主要な」
- パターン: 範囲の曖昧性（代表系）
- 不足情報: ブラウザ名、バージョン、デバイス

質問設計:
Q1: 「主要な」とは具体的にどのブラウザですか？
Q2: バージョンの範囲は？
Q3: モバイルブラウザは含みますか？
Q4: テストの頻度は？

回答例:
A1: Chrome、Firefox、Safari、Edge
A2: 直近2バージョン
A3: iOS Safari、Android Chromeを含む
A4: リリース前に全ブラウザでテスト

After:
「対応ブラウザとテスト基準:

 サポート対象（完全互換性保証）:

 デスクトップ:
 - Google Chrome: 最新版および1つ前のバージョン
 - Mozilla Firefox: 最新版および1つ前のバージョン
 - Apple Safari: 最新版および1つ前のバージョン（macOS）
 - Microsoft Edge: 最新版および1つ前のバージョン

 モバイル:
 - iOS Safari: iOS 14以降
 - Android Chrome: Android 9以降

 最小画面サイズ:
 - デスクトップ: 1280x720px
 - タブレット: 768x1024px
 - モバイル: 375x667px（iPhone SE相当）

 非サポート（動作保証なし）:
 - Internet Explorer: 全バージョン（サポート終了）
 - Opera、Vivaldi等: 基本的に動作するが、テスト対象外
 - 古いバージョン: 上記の範囲外

 テスト基準:
 - 自動テスト: Playwright、各ブラウザで実行
 - 手動テスト: リリース前に全ブラウザで実施
 - 互換性チェック: Browserstack、月次で実行

 段階的サポート終了:
 - バージョンアップ: ブラウザの新版リリース後1ヶ月以内に対応
 - 古いバージョンの終了: 3ヶ月前に告知」
```

### パターン4: 条件の曖昧性（Conditional Ambiguity）

#### 定義と特徴

動作の条件が「場合によって」「必要に応じて」など不明確な状態。
どのような状況で、どのような動作をするのかが明示されていない。

#### 検出キーワード一覧

**条件不明系**:
- 場合によって、状況次第で、ケースバイケース
- 必要に応じて、適宜、随時
- 時には、場合がある、することがある

**可能性系**:
- 可能であれば、できれば、望ましくは
- なるべく、極力、できる限り
- 〜してもよい、〜できる

**判断保留系**:
- 検討する、考慮する、判断する
- 評価する、決定する

#### 除去手法

**1. すべての条件を列挙**

```markdown
Before（曖昧）:
「必要に応じてログ出力」

After（明確）:
「ログ出力の条件とレベル:

 ERROR level（必須）:
 - すべてのエラー、例外をキャッチ
 - データベース接続エラー
 - サードパーティAPI呼び出しの失敗
 - ファイルI/Oエラー

 WARN level（推奨）:
 - API応答時間 > 1秒
 - メモリ使用率 > 80%
 - ディスク使用率 > 90%
 - リトライ処理の発生

 INFO level（通常動作）:
 - ユーザーログイン、ログアウト
 - データの作成、更新、削除
 - バッチ処理の開始、終了

 DEBUG level（開発時のみ）:
 - 環境変数DEBUG=trueの場合のみ有効
 - すべての関数呼び出し
 - SQLクエリの実行内容
 - 外部API呼び出しのリクエスト/レスポンス

 ログ保存:
 - ERROR/WARN: 永続的に保存（90日間）
 - INFO: 30日間保存
 - DEBUG: 7日間保存または即座に削除

 ログ出力先:
 - 本番環境: CloudWatch Logs
 - ステージング環境: CloudWatch Logs + stdout
 - 開発環境: stdout」

除去プロセス:
1. 「必要」の定義 → 4つのレベルに分類
2. 各レベルの条件を列挙 → ERROR 4種、WARN 4種
3. 環境による違いを明示 → 本番、ステージング、開発
4. 保存期間の明示 → 90日、30日、7日
```

**2. 条件式で表現**

```markdown
Before（曖昧）:
「状況次第で承認が必要」

After（明確）:
「承認フローの条件:

 承認が必要な条件（以下のいずれかに該当）:

 条件1: 金額ベース
 - (申請金額 >= 100,000円) AND (申請者.role != '部長')
 - (申請金額 >= 500,000円) AND (申請者.role != '本部長')
 - (申請金額 >= 1,000,000円) → 常に承認必要

 条件2: カテゴリーベース
 - 申請.category == '資産購入'
 - 申請.category == '人件費'
 - 申請.category == '外部委託'

 条件3: 予算超過
 - (今月の累計支出 / 今月の予算) > 1.0
 - (前月の予算超過率) > 0.1

 承認者の決定ロジック:

 STEP1: 金額による承認者の決定
 - 10万円未満: 承認不要
 - 10万円以上〜50万円未満: 課長
 - 50万円以上〜100万円未満: 部長
 - 100万円以上: 本部長

 STEP2: カテゴリーによる追加承認
 - 資産購入: 財務部長の承認が追加で必要
 - 人件費: 人事部長の承認が追加で必要

 STEP3: 予算超過時の追加承認
 - 予算超過: 予算管理者の承認が追加で必要

 承認フロー:
 - 承認者が複数の場合: 並列承認（全員の承認が必要）
 - 承認期限: 申請から3営業日以内
 - 期限超過: 自動エスカレーション（上位承認者に通知）
 - 却下: 申請者に通知、理由の入力が必須」

除去プロセス:
1. 「状況」を3つの条件に分類 → 金額、カテゴリー、予算超過
2. 条件式で表現 → AND、OR、比較演算子
3. 承認者の決定ロジックを明示 → STEP1-3
4. フローの詳細を明示 → 並列、期限、エスカレーション
```

**3. デフォルト動作の明示**

```markdown
Before（曖昧）:
「可能であればキャッシュを使用」

After（明確）:
「キャッシュ戦略:

 デフォルト動作（キャッシュを使用）:
 - 対象: GET /api/users、GET /api/products
 - キャッシュ先: Redis
 - TTL（有効期限）: 5分
 - キャッシュキー: エンドポイント + クエリパラメータのハッシュ

 キャッシュを使用しない条件:

 条件1: クエリパラメータでの指定
 - ?nocache=true が指定された場合
 - 例: GET /api/users?nocache=true

 条件2: データ更新直後
 - POST、PUT、DELETE操作の後5秒間
 - 対象リソースのキャッシュを削除

 条件3: 管理者操作
 - 管理者がキャッシュクリアボタンをクリック
 - 全キャッシュまたは特定エンドポイントを選択可能

 条件4: キャッシュエラー
 - Redisへの接続エラー
 - フォールバック: データベースから直接取得

 キャッシュの更新:
 - Write-Through: データ更新時にキャッシュも更新
 - Lazy Loading: キャッシュミス時にデータベースから取得してキャッシュ

 パフォーマンス監視:
 - キャッシュヒット率: 80%以上を目標
 - キャッシュミス時の応答時間: <500ms
 - キャッシュヒット時の応答時間: <50ms」

除去プロセス:
1. デフォルト動作を明示 → キャッシュを使用、TTL 5分
2. 例外条件を4つに分類 → クエリパラメータ、データ更新、管理者、エラー
3. フォールバック動作を明示 → データベースから直接取得
4. パフォーマンス目標を設定 → ヒット率80%、応答時間<50ms
```

**4. 状態遷移図での表現**

```markdown
Before（曖昧）:
「場合によって再送信」

After（明確）:
「メッセージ再送信のロジック:

 状態遷移:

 [送信待機] → [送信中] → [送信完了]
     ↓           ↓
     ↓      [送信失敗]
     ↓           ↓
     ↓      [リトライ1回目] → [送信完了]
     ↓           ↓
     ↓      [送信失敗]
     ↓           ↓
     ↓      [リトライ2回目] → [送信完了]
     ↓           ↓
     ↓      [送信失敗]
     ↓           ↓
     ↓      [リトライ3回目] → [送信完了]
     ↓           ↓
     ↓      [送信失敗]
     ↓           ↓
     └─→   [Dead Letter Queue]

 再送信の条件:

 条件1: ネットワークエラー（リトライ可能）
 - HTTPステータス: 500, 502, 503, 504
 - タイムアウト: 接続タイムアウト、読み取りタイムアウト
 - 接続エラー: DNS解決失敗、接続拒否

 条件2: 一時的なエラー（リトライ可能）
 - HTTPステータス: 429（Too Many Requests）
 - レート制限エラー

 条件3: 致命的なエラー（リトライ不可）
 - HTTPステータス: 400, 401, 403, 404
 - バリデーションエラー
 - 認証エラー

 リトライ戦略:
 - 最大リトライ回数: 3回
 - リトライ間隔: 指数バックオフ
   - 1回目: 2秒後
   - 2回目: 4秒後
   - 3回目: 8秒後
 - ジッター: ±20%（競合回避）

 Dead Letter Queue:
 - 3回のリトライ失敗後に移動
 - 保存期間: 7日間
 - 手動での再送信: 管理画面から可能
 - アラート: Slackに通知」

除去プロセス:
1. 「場合」を状態遷移で表現 → 7状態を図示
2. 再送信の条件を3つに分類 → ネットワーク、一時的、致命的
3. リトライ戦略を数値化 → 3回、指数バックオフ、ジッター
4. 失敗時の処理を明示 → Dead Letter Queue、アラート
```

#### 実践例

**例1: 通知タイミング**

```markdown
Before:
「重要なイベントが発生した場合に通知」

分析:
- 曖昧なキーワード: 「重要な」「発生した場合」
- パターン: 条件の曖昧性（条件不明系）
- 不足情報: 重要の定義、イベントの種類、通知方法

質問設計:
Q1: 「重要な」とは、どのような基準ですか？
Q2: どのようなイベントが対象ですか？
Q3: 誰に、どのように通知しますか？
Q4: 通知の頻度は？

回答例:
A1: ユーザーの行動に影響するもの
A2: 支払い完了、注文キャンセル、システムエラー
A3: ユーザーにEmail、管理者にSlack
A4: 即座に（最大5分以内）

After:
「通知の条件と方法:

 通知対象イベント（ユーザー向け）:

 HIGH優先度（即座に通知）:
 - 支払い完了: 決済処理の完了後、1分以内
 - 注文キャンセル: キャンセル処理の完了後、1分以内
 - パスワード変更: 変更完了後、即座に
 - アカウントロック: 5回の連続ログイン失敗後、即座に

 MEDIUM優先度（5分以内に通知）:
 - 商品発送: 発送処理の完了後、5分以内
 - レビュー投稿: 承認後、5分以内
 - ポイント付与: 付与処理の完了後、5分以内

 LOW優先度（日次バッチで通知）:
 - おすすめ商品: 毎日午前10時に配信
 - クーポン情報: 週1回、月曜日午前10時

 通知対象イベント（管理者向け）:

 CRITICAL（即座に通知、Slackチャネル）:
 - システムエラー: 500エラー、データベース接続エラー
 - セキュリティアラート: 不正ログイン試行（10回/時）
 - サーバーダウン: ヘルスチェック失敗

 WARNING（5分間隔でまとめて通知、Slack）:
 - パフォーマンス劣化: 応答時間>1秒が10回連続
 - エラー率上昇: エラー率>1%が継続

 通知方法:

 ユーザー:
 - Email: SendGrid経由、テンプレート使用
 - プッシュ通知: FCM経由（オプトイン必須）
 - アプリ内通知: リアルタイム（WebSocket）

 管理者:
 - Slack: #alerts チャネル（CRITICAL）、#warnings チャネル（WARNING）
 - Email: 管理者グループ（1日の終わりにサマリー）

 通知の抑制:
 - 同一イベントの重複防止: 5分間のクールダウン
 - 通知上限: 100件/日/ユーザー
 - 深夜の通知: 22時〜6時は抑制（CRITICAL以外）」
```

### パターン5: 主体の曖昧性（Subject Ambiguity）

#### 定義と特徴

誰が・何がアクションを行うのかが不明確な状態。
アクターの特定、権限レベル、トリガーが明示されていない。

#### 検出キーワード一覧

**主語省略系**:
- ユーザーは、管理者は、システムは
- データは、ファイルは、情報は
- 〜される、〜できる、〜しなければならない

**自動化系**:
- 自動的に、自動で、自動化される
- 定期的に、随時、継続的に

**権限不明系**:
- 権限のあるユーザー、許可されたユーザー
- 担当者、責任者、管理者

#### 除去手法

**1. 具体的なアクターを特定**

```markdown
Before（曖昧）:
「ユーザーは削除できる」

After（明確）:
「削除機能の権限:

 管理者ロール:
 - 自分が作成したすべてのレコードを削除可能
 - 他のユーザーが作成したレコードを削除可能
 - 削除理由の入力は任意
 - 削除履歴: 永続的に保存

 編集者ロール:
 - 自分が作成したレコードのみ削除可能
 - 作成から24時間以内のみ削除可能
 - 削除理由の入力は必須
 - 削除履歴: 30日間保存

 閲覧者ロール:
 - 削除権限なし

 削除の実行:
 - 論理削除: deleted_at にタイムスタンプを設定
 - 物理削除: 管理者のみ、削除から30日後にバッチ処理で実行
 - 復元: 管理者のみ、論理削除から30日以内

 削除の監査:
 - ログ記録: ユーザーID、削除日時、削除理由、IPアドレス
 - 通知: 管理者に日次レポートで通知」

除去プロセス:
1. 「ユーザー」をロール別に分類 → 管理者、編集者、閲覧者
2. 各ロールの権限を明示 → すべて、自分のみ、なし
3. 削除の種類を明示 → 論理削除、物理削除、復元
4. 監査の詳細を明示 → ログ、通知
```

**2. 権限レベルを明示**

```markdown
Before（曖昧）:
「管理者は設定を変更できる」

After（明確）:
「設定変更の権限マトリクス:

 システム管理者（最高権限）:

 変更可能な設定:
 - システム全体の設定: タイムゾーン、言語、通貨
 - セキュリティ設定: パスワードポリシー、セッションタイムアウト
 - 統合設定: サードパーティAPI、Webhook
 - ユーザー管理: すべてのユーザーの作成、編集、削除
 - ロール管理: 新規ロールの作成、権限の付与

 変更不可の設定:
 - ライセンス設定（サポートチームのみ）
 - データベース接続文字列（インフラチームのみ）

 組織管理者（組織スコープ）:

 変更可能な設定:
 - 組織情報: 組織名、ロゴ、配色テーマ
 - ユーザー管理: 自組織のユーザーのみ作成、編集、削除
 - 部門管理: 部門の作成、編集、削除
 - 通知設定: 自組織の通知ルール

 変更不可の設定:
 - システム全体の設定
 - セキュリティ設定
 - 他組織のデータ

 部門管理者（部門スコープ）:

 変更可能な設定:
 - 部門情報: 部門名、責任者
 - ユーザー管理: 自部門のユーザーのみ編集（削除不可）
 - 通知設定: 自部門の通知ルール

 変更不可の設定:
 - 組織情報
 - 他部門のデータ
 - ユーザーのロール変更

 一般ユーザー:

 変更可能な設定:
 - プロフィール: 名前、メールアドレス、パスワード
 - 個人設定: テーマ（ライト/ダーク）、通知ON/OFF

 変更不可の設定:
 - すべての管理設定

 設定変更の承認フロー:

 即座に反映（承認不要）:
 - 個人設定、プロフィール変更

 承認が必要:
 - セキュリティ設定変更: システム管理者2名の承認
 - ロール変更: 上位管理者の承認

 変更履歴:
 - すべての設定変更を記録
 - 変更者、変更日時、変更前後の値
 - 監査ログとして永続的に保存」

除去プロセス:
1. 「管理者」を4段階に分類 → システム、組織、部門、一般
2. 各レベルの権限を明示 → 変更可能、変更不可
3. 承認フローを明示 → 即座、承認必要
4. 監査の詳細を明示 → 変更履歴、監査ログ
```

**3. トリガーと責任を明確化**

```markdown
Before（曖昧）:
「データは定期的に同期される」

After（明確）:
「データ同期の仕組み:

 トリガー（自動実行）:

 スケジュール同期:
 - ツール: AWS EventBridge
 - cron式: 0 */15 * * * *（15分ごと）
 - 実行環境: AWS Lambda（function: sync-data）
 - タイムゾーン: UTC
 - 開始時刻: 毎時0分、15分、30分、45分

 イベントベース同期:
 - トリガー: サードパーティのWebhook受信
 - エンドポイント: POST /api/webhooks/data-sync
 - 認証: HMAC署名検証
 - 処理: Lambda関数を非同期で呼び出し

 手動同期:
 - トリガー: システム管理者が「同期」ボタンをクリック
 - 画面: 管理画面 > データ管理 > 手動同期
 - 制限: 1時間に1回まで（クールダウン）

 同期処理の詳細:

 STEP1: データ取得（Lambda関数）:
 - サードパーティAPI: GET /api/v1/records
 - 認証: Bearer token（AWS Secrets Managerから取得）
 - タイムアウト: 30秒
 - リトライ: 3回まで、指数バックオフ

 STEP2: データ変換（Lambda関数）:
 - 入力: JSON形式のサードパーティデータ
 - 出力: 内部データモデルに変換
 - バリデーション: スキーマ検証、必須項目チェック
 - エラー処理: バリデーションエラーはログ記録、スキップ

 STEP3: データ保存（Lambda関数）:
 - データベース: Amazon RDS（PostgreSQL）
 - トランザクション: BEGIN → UPSERT → COMMIT
 - 競合解決: サードパーティのタイムスタンプが新しい場合のみ更新
 - エラー処理: ロールバック、CloudWatch Logsに記録

 STEP4: 通知（Lambda関数）:
 - 成功: CloudWatch Metricsに成功回数を記録
 - 失敗: Slackの#alertsチャネルに通知
 - サマリー: 日次レポートをEmailで送信

 責任者:
 - 設計: データエンジニアチーム
 - 実装: バックエンドチーム
 - 運用: インフラチーム
 - 監視: SREチーム

 エラー処理とリカバリー:

 一時的なエラー:
 - ネットワークエラー、タイムアウト: 自動リトライ（3回）
 - レート制限エラー: 5分後に再試行

 恒久的なエラー:
 - 認証エラー: Slackアラート、手動対応が必要
 - データフォーマットエラー: ログ記録、次回の同期で再試行

 監視とアラート:
 - 成功率: 95%以上を目標、下回った場合はSlack通知
 - 同期遅延: 30分以上遅延した場合はSlack通知
 - エラー率: 5%以上の場合はSlack通知」

除去プロセス:
1. 「定期的」の具体化 → 15分ごと、cron式
2. トリガーを3種類に分類 → スケジュール、イベント、手動
3. 処理の詳細を4ステップで明示 → 取得、変換、保存、通知
4. 責任者の明示 → 設計、実装、運用、監視
```

**4. アクターと権限のマトリクス**

```markdown
Before（曖昧）:
「権限のあるユーザーはレポートを生成できる」

After（明確）:
「レポート生成の権限マトリクス:

 アクター × レポート種別 × 権限:

 ┌──────────┬─────────┬─────────┬─────────┬─────────┐
 │ アクター     │ 日次      │ 週次      │ 月次      │ カスタム  │
 ├──────────┼─────────┼─────────┼─────────┼─────────┤
 │ システム管理者│ 全て      │ 全て      │ 全て      │ 全て      │
 │             │ 生成/閲覧  │ 生成/閲覧  │ 生成/閲覧  │ 生成/閲覧  │
 ├──────────┼─────────┼─────────┼─────────┼─────────┤
 │ 組織管理者    │ 自組織    │ 自組織    │ 自組織    │ 自組織    │
 │             │ 生成/閲覧  │ 生成/閲覧  │ 生成/閲覧  │ 生成/閲覧  │
 ├──────────┼─────────┼─────────┼─────────┼─────────┤
 │ 部門管理者    │ 自部門    │ 自部門    │ 自部門    │ 自部門    │
 │             │ 閲覧のみ  │ 閲覧のみ  │ 生成/閲覧  │ 生成/閲覧  │
 ├──────────┼─────────┼─────────┼─────────┼─────────┤
 │ 一般ユーザー  │ 不可      │ 不可      │ 不可      │ 不可      │
 │             │ -         │ -         │ -         │ -         │
 └──────────┴─────────┴─────────┴─────────┴─────────┘

 レポート生成の詳細:

 日次レポート:
 - トリガー: cron（毎日午前6時、自動生成）
 - アクター: システム（Lambda関数）
 - 対象データ: 前日0時〜23時59分
 - 出力形式: PDF
 - 保存先: S3（/reports/daily/YYYY-MM-DD.pdf）
 - 配信: Email（組織管理者、部門管理者）

 週次レポート:
 - トリガー: cron（毎週月曜日午前6時、自動生成）
 - アクター: システム（Lambda関数）
 - 対象データ: 前週月曜日〜日曜日
 - 出力形式: PDF + Excel
 - 保存先: S3（/reports/weekly/YYYY-Www.pdf）
 - 配信: Email（組織管理者、部門管理者）

 月次レポート:
 - トリガー: 手動生成（部門管理者以上）または自動（毎月1日午前6時）
 - アクター: 部門管理者、組織管理者、システム管理者、またはシステム
 - 対象データ: 前月1日〜末日
 - 出力形式: PDF + Excel + PowerPoint
 - 保存先: S3（/reports/monthly/YYYY-MM.pdf）
 - 配信: Email（組織管理者のみ）

 カスタムレポート:
 - トリガー: 手動生成（部門管理者以上）
 - アクター: 部門管理者、組織管理者、システム管理者
 - 対象データ: ユーザーが指定した期間（最大1年間）
 - 出力形式: PDF、Excel、CSV（ユーザーが選択）
 - 保存先: S3（/reports/custom/user-{user_id}/{timestamp}.pdf）
 - 配信: ダウンロードリンクをEmail送信
 - 生成時間: 即時（データ量により1-5分）
 - 制限: 1ユーザーあたり1日10回まで

 権限の検証:
 - 認証: JWTトークンのロールクレーム
 - 認可: ロールベースアクセス制御（RBAC）
 - スコープ: organizationId、departmentIdでフィルタリング
 - エラー: 権限不足の場合は403 Forbidden

 監査ログ:
 - 記録内容: ユーザーID、レポート種別、生成日時、対象期間
 - 保存先: データベース（audit_logs テーブル）
 - 保存期間: 1年間」

除去プロセス:
1. 「権限のある」を4段階に分類 → システム、組織、部門、一般
2. レポート種別ごとに権限を明示 → マトリクス表
3. 各レポートの詳細を明示 → トリガー、アクター、形式、配信
4. 権限検証と監査を明示 → RBAC、監査ログ
```

#### 実践例

**例1: バックアップ処理**

```markdown
Before:
「システムは自動的にバックアップする」

分析:
- 曖昧なキーワード: 「自動的に」
- パターン: 主体の曖昧性（自動化系）
- 不足情報: トリガー、責任者、頻度、範囲

質問設計:
Q1: 「自動的に」とは、何がトリガーですか？
Q2: どのデータをバックアップしますか？
Q3: どこに保存しますか？
Q4: 復元のテストは行いますか？

回答例:
A1: cron、毎日午前2時
A2: PostgreSQLのすべてのデータベース
A3: AWS S3（リージョン冗長化）
A4: 四半期ごとに復元テストを実施

After:
「バックアップシステムの仕様:

 トリガーと実行主体:

 定期バックアップ（自動実行）:
 - ツール: AWS EventBridge + Lambda
 - cron式: 0 2 * * * *（毎日午前2時、UTC）
 - 実行関数: backup-databases（Lambda）
 - タイムゾーン: UTC（日本時間では午前11時）

 手動バックアップ:
 - トリガー: システム管理者が「今すぐバックアップ」ボタンをクリック
 - 画面: 管理画面 > データ管理 > バックアップ
 - 制限: 1日に5回まで

 バックアップ対象:

 フルバックアップ（毎日）:
 - PostgreSQLデータベース: すべてのテーブル
 - ツール: pg_dump（カスタム形式）
 - データ量: 約100GB（圧縮後: 約20GB）
 - 所要時間: 約30分

 増分バックアップ（1時間ごと）:
 - PostgreSQLのWAL（Write-Ahead Log）
 - ツール: pg_receivewal
 - 保存先: S3（/backups/wal/）
 - PITR（Point-In-Time Recovery）を可能にする

 バックアップ手順（Lambda関数）:

 STEP1: データベースのバックアップ:
 - コマンド: pg_dump -Fc -Z9 -f backup.dump
 - オプション: -Fc（カスタム形式）、-Z9（最大圧縮）
 - エラー処理: 失敗時はSlackアラート

 STEP2: S3へのアップロード:
 - バケット: my-app-backups（バージョニング有効）
 - パス: /backups/full/YYYY-MM-DD-HHmmss.dump
 - 暗号化: SSE-S3（サーバー側暗号化）
 - ストレージクラス: S3 Standard-IA（30日後にGlacierに移行）

 STEP3: 検証:
 - ファイルサイズ: 期待値との比較（±10%以内）
 - チェックサム: SHA256ハッシュを計算、保存
 - 整合性チェック: pg_restore --list でメタデータ検証

 STEP4: 古いバックアップの削除:
 - 保存期間: フルバックアップ30日、WAL 7日
 - ライフサイクルポリシー: S3のライフサイクルルール
 - Glacierへの移行: 30日後
 - 完全削除: 90日後

 STEP5: 通知:
 - 成功: CloudWatch Metricsに記録
 - 失敗: Slackの#alertsチャネルに即座に通知
 - サマリー: 週次レポートをEmailで送信

 バックアップの保存先:

 プライマリリージョン: ap-northeast-1（東京）
 - S3バケット: my-app-backups-primary
 - レプリケーション: 有効（セカンダリリージョンへ）

 セカンダリリージョン: us-west-2（オレゴン）
 - S3バケット: my-app-backups-secondary
 - 用途: ディザスタリカバリー

 復元手順:

 PITR（Point-In-Time Recovery）:
 - 手順: pg_basebackup + WAL再生
 - 復元可能期間: 過去7日以内
 - 実行者: システム管理者、インフラチーム
 - 所要時間: 約1時間

 フルリストア:
 - 手順: pg_restore backup.dump
 - 対象: 特定の日時のフルバックアップ
 - 実行者: システム管理者、インフラチーム
 - 所要時間: 約2時間

 復元テスト:
 - 頻度: 四半期ごと（3ヶ月に1回）
 - 実行者: インフラチーム、QAチーム
 - 手順: ステージング環境で復元テストを実施
 - 検証: データ整合性、アプリケーション動作確認
 - レポート: テスト結果をドキュメント化、CTO承認

 責任者:
 - 設計: インフラチーム
 - 実装: インフラチーム、バックエンドチーム
 - 運用: インフラチーム
 - 監視: SREチーム
 - 復元テスト: QAチーム

 監視とアラート:
 - バックアップ成功率: 100%を目標
 - 失敗時: 即座にSlackアラート
 - 遅延: 午前3時までに完了しない場合はアラート
 - ストレージ使用量: 月次でレビュー、コスト最適化」
```

## まとめ

このガイドでは、5つの曖昧性パターンの検出と除去手法を実践的に解説しました。

**重要なポイント**:
1. **体系的な検出**: キーワードリストで網羅的に曖昧性を発見
2. **具体的な除去**: 数値、単位、条件、主体を明示的に記述
3. **測定可能性**: すべての要件が検証可能な形式に変換
4. **質問技法**: ステークホルダーから具体的な情報を引き出す

**実践のステップ**:
1. 要件ドキュメントをキーワード検索で曖昧性を検出
2. 各曖昧性に対して質問を設計
3. 回答を基に要件を再記述
4. 測定可能性と検証可能性を確認

**成功の鍵**:
- 曖昧性の早期検出（要件定義フェーズで実施）
- ステークホルダーとの継続的な対話
- 数値と条件の明示的な記述
- テスト可能な受け入れ基準への変換
