# テストファースト原則

## 概要

テストファーストとは、実装コードを書く前にテストを書く開発手法です。
単なる順序の問題ではなく、設計と品質に大きな影響を与えるプラクティスです。

---

## 原則1: テストは仕様である

### 概念

テストコードは実行可能な仕様書として機能します。
テストを先に書くことで、仕様を明確に定義できます。

### メリット

1. **仕様の曖昧さを早期発見**
   - テストを書く過程で不明確な点が明らかに
   - 実装前に仕様を確定できる

2. **APIの使いやすさを事前検証**
   - テストはAPIの最初のクライアント
   - 使いにくいAPIはテストも書きにくい

3. **実行可能なドキュメント**
   - テストは常に最新の仕様を反映
   - ドキュメントの陳腐化を防止

### 実践

```markdown
## 仕様: ユーザー認証

1. 正しい認証情報でログイン成功
2. 誤ったパスワードでログイン失敗
3. 存在しないユーザーでログイン失敗
4. アカウントロック時はログイン不可
```

↓ テストファーストで上記仕様を検証可能なコードに変換

---

## 原則2: シンプルな設計の創発

### 概念

テストファーストで開発することで、テスト可能な（=疎結合な）設計が自然に生まれます。

### 創発パターン

1. **依存性注入の自然な導入**
   - テストで依存を置き換えるため
   - ハードコードされた依存は排除される

2. **単一責任原則への準拠**
   - テストしやすい = 責任が単一
   - 複数の責任を持つクラスはテストが複雑

3. **インターフェースの明確化**
   - テストから使うことで必要なインターフェースが明確に
   - 不要なメソッドは追加されない

### テスト可能性が促進する設計

| テスト困難な設計 | テスト可能な設計 |
|---------------|----------------|
| グローバル状態 | 依存性注入 |
| 密結合 | 疎結合 |
| 複雑なコンストラクタ | ファクトリパターン |
| 直接的なDB接続 | リポジトリパターン |
| 外部API直接呼び出し | アダプターパターン |

---

## 原則3: 勇気あるリファクタリング

### 概念

テストがあることで、安心してコードを改善できます。

### 心理的効果

1. **変更への恐怖の軽減**
   - テストが安全網として機能
   - 壊れたらすぐに分かる

2. **継続的改善の習慣化**
   - 小さな改善を積み重ねる
   - 「後で直す」が実行される

3. **技術的負債の積極的返済**
   - リファクタリングのコストが低下
   - 早期に負債を返済可能

### リファクタリングの安全性

```
テストあり:
  変更 → テスト実行 → 成功/失敗が即座に判明

テストなし:
  変更 → 手動テスト/目視確認 → 本番で問題発覚
```

---

## 原則4: YAGNI（You Aren't Gonna Need It）

### 概念

テストファーストは、YAGNIを強制します。
テストがない機能は実装しません。

### 実践

1. **テストがある機能のみ実装**
   - 「後で使うかも」は実装しない
   - 必要になったらテストを追加

2. **過剰な抽象化の防止**
   - テストで必要になるまで抽象化しない
   - 具体的なケースから一般化

3. **インターフェースの最小化**
   - テストで使うメソッドのみ公開
   - 内部詳細は隠蔽

---

## 原則5: フィードバックループの短縮

### 概念

テストファーストは、フィードバックループを最短にします。

### フィードバックの種類

1. **設計フィードバック**
   - テストが書きにくい = 設計に問題
   - 即座に設計を改善

2. **仕様フィードバック**
   - テストで仕様の不明確さが露呈
   - 実装前に仕様を確定

3. **品質フィードバック**
   - テスト失敗 = 品質問題
   - すぐに修正可能

### フィードバック速度の比較

| アプローチ | フィードバック時間 |
|----------|-----------------|
| テストファースト | 秒〜分 |
| テスト後付け | 分〜時間 |
| 手動テスト | 時間〜日 |
| 本番監視 | 日〜週 |

---

## テストファーストの実践ステップ

### Step 1: 機能を小さく分解

```markdown
大きな機能:
  「ユーザー登録機能を実装」

小さな機能に分解:
  1. メールアドレスのバリデーション
  2. パスワードの強度チェック
  3. ユーザー情報の保存
  4. 確認メールの送信
  5. 重複チェック
```

### Step 2: 最も単純なケースから開始

```markdown
ユースケース:
  「メールアドレスのバリデーション」

テストケース（優先順）:
  1. 正常なメールアドレスは有効
  2. @がないメールアドレスは無効
  3. ドメインがないメールアドレスは無効
  4. 空文字は無効
```

### Step 3: テストを書く

```markdown
テスト構造:
  - Given: 前提条件
  - When: 操作
  - Then: 期待結果
```

### Step 4: テストを通す最小実装

```markdown
原則:
  - テストを通すことだけに集中
  - 完璧を求めない
  - 次のテストで一般化
```

### Step 5: リファクタリング

```markdown
観点:
  - 重複の排除
  - 命名の改善
  - 構造の最適化
```

---

## 判断基準チェックリスト

### テストファースト準拠

- [ ] 実装より先にテストを書いているか？
- [ ] テストは失敗を確認してから実装に進んでいるか？
- [ ] テストで仕様が明確に定義されているか？

### 設計品質

- [ ] テストが書きやすい設計になっているか？
- [ ] 依存性注入が適用されているか？
- [ ] 単一責任原則に準拠しているか？

### YAGNI準拠

- [ ] テストのない機能を実装していないか？
- [ ] 過剰な抽象化をしていないか？
- [ ] 必要最小限のインターフェースか？

---

## 参考文献

- Kent Beck『テスト駆動開発』
- Robert C. Martin『Clean Code』
- Michael Feathers『Working Effectively with Legacy Code』
