# Red-Green-Refactor サイクル詳細

## 概要

Red-Green-Refactorは、TDDの核心となる3フェーズの反復サイクルです。
このサイクルを厳密に守ることで、品質の高いコードを継続的に生産できます。

---

## Phase 1: Red（赤）- 失敗するテストを書く

### 目的
- 期待される振る舞いを明確に定義する
- テストが実際に検証を行っていることを確認する

### 原則

1. **テストは最初に失敗しなければならない**
   - 失敗しないテストは何も検証していない
   - 常にテストが正しく動作していることを確認

2. **失敗メッセージは明確に**
   - 何が期待されているかを伝える
   - デバッグ時間を短縮

3. **一度に一つの振る舞いのみ**
   - 複数の検証を避ける
   - 失敗原因を特定しやすくする

### チェックリスト

- [ ] テストは実装前に書かれているか？
- [ ] テストは期待通り失敗しているか？
- [ ] エラーメッセージは何を修正すべきか明確に示しているか？
- [ ] 一つのテストで一つの振る舞いのみを検証しているか？

### アンチパターン

- ❌ 実装後にテストを書く
- ❌ 複数の振る舞いを一つのテストで検証
- ❌ 曖昧な期待値（"something"、"any"など）

---

## Phase 2: Green（緑）- テストを通す最小限の実装

### 目的
- テストを成功させる最もシンプルなコードを書く
- 動作するコードを素早く手に入れる

### 原則

1. **テストを通すためだけのコード**
   - 余計な機能を追加しない
   - YAGNIの徹底

2. **「動作するきれいなコード」は後回し**
   - まず動作させる
   - きれいにするのはRefactorフェーズ

3. **過剰な実装を避ける**
   - 次のテストが追加されるまで待つ
   - 推測で実装しない

### 実装パターン

#### Fake It Till You Make It
```
1. ハードコードした値でテストを通す
2. 追加のテストで一般化を強制
3. 段階的に正しい実装へ
```

#### Obvious Implementation
```
1. 実装が明白な場合は直接書く
2. 失敗したら「Fake It」に戻る
3. 自信過剰にならない
```

### チェックリスト

- [ ] 実装はテストを通す最小限か？
- [ ] 不要な機能を追加していないか？
- [ ] すべてのテストが成功しているか？
- [ ] 次のテストを追加する準備ができているか？

### アンチパターン

- ❌ 完璧な実装を目指す
- ❌ 将来の要件を先取り
- ❌ 複数のテストを一度に通そうとする

---

## Phase 3: Refactor（リファクタ）- コードを改善する

### 目的
- テストを通したまま、コードの品質を向上させる
- 技術的負債を発生させない

### 原則

1. **動作を変えずに構造を改善**
   - 外部から見た振る舞いは同じ
   - 内部構造のみ改善

2. **DRY（Don't Repeat Yourself）の適用**
   - 重複コードの排除
   - 共通化と抽象化

3. **命名の改善**
   - 意図を明確に表現
   - ドメイン用語の使用

### リファクタリング候補

1. **コードの重複**
   - 同じコードが複数箇所にある
   - 類似したパターンが繰り返される

2. **長すぎるメソッド**
   - 単一責任の違反
   - 抽出の機会

3. **不明確な命名**
   - 何をしているか分からない
   - 略語や汎用的な名前

4. **複雑な条件分岐**
   - ネストが深い
   - 早期リターンで単純化可能

### チェックリスト

- [ ] リファクタリング後もすべてのテストが成功するか？
- [ ] コードの重複は排除されたか？
- [ ] 命名は改善されたか？
- [ ] 可読性は向上したか？
- [ ] 複雑性は減少したか？

### アンチパターン

- ❌ 機能追加と同時にリファクタリング
- ❌ テストを通さずにリファクタリング
- ❌ 大規模な変更を一度に行う

---

## サイクルのリズム

### 理想的なサイクル時間

- **Red**: 1-5分（テスト作成）
- **Green**: 1-10分（最小実装）
- **Refactor**: 1-5分（改善）

**合計**: 3-20分/サイクル

### サイクルが長くなる兆候

1. **ステップが大きすぎる**
   - より小さな単位に分割
   - 中間目標を設定

2. **テストが複雑すぎる**
   - 単純なケースから始める
   - Triangulationで段階的に

3. **依存が多すぎる**
   - テストダブルの活用
   - 依存性注入の導入

---

## トラブルシューティング

### 問題: テストが通らない

**原因**: 実装が不完全または誤り

**解決策**:
1. エラーメッセージを注意深く読む
2. より小さなステップに戻る
3. 「Fake It」パターンで確実に進める

### 問題: リファクタリングで壊れる

**原因**: テストが不十分または脆弱

**解決策**:
1. テストカバレッジを確認
2. より小さなリファクタリングに分割
3. 必要に応じてテストを追加

### 問題: サイクルが遅い

**原因**: ステップが大きすぎる

**解決策**:
1. より小さな機能単位に分割
2. 中間目標を設定
3. Triangulationを活用

---

## 参考文献

- Kent Beck『テスト駆動開発』第1部: Money Example
- Robert C. Martin『Clean Code』Chapter 9: Unit Tests
