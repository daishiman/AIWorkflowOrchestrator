# テスト駆動設計の創発

## 概要

TDDを実践すると、良い設計が「創発」（自然に出現）します。
テストが書きやすい設計は、同時に良い設計でもあります。

---

## TDDが促進する設計原則

### SOLID原則への自然な準拠

TDDを正しく実践すると、SOLID原則に自然と準拠した設計になります。

#### S - 単一責任原則（Single Responsibility）

**TDDの促進効果**:
- テストしやすい = 責任が単一
- 複数の責任 = テストが複雑になる

**兆候**:
```markdown
テスト困難: 「このクラスをテストするには10個のモックが必要」
  → 責任が多すぎる

テスト容易: 「このクラスは2つのモックでテスト可能」
  → 責任が適切
```

#### O - 開放閉鎖原則（Open/Closed）

**TDDの促進効果**:
- 拡張でテストを追加
- 既存テストは変更不要

**パターン**:
```markdown
新機能追加:
  1. 新しいテストを書く
  2. 新しいクラス/メソッドを追加
  3. 既存テストは影響なし
```

#### L - リスコフ置換原則（Liskov Substitution）

**TDDの促進効果**:
- 派生クラスは基底クラスのテストをすべてパス
- テストダブルが置換可能

**検証方法**:
```markdown
1. 基底クラスのテストを実行
2. 派生クラスで同じテストを実行
3. すべてパスすればLSP準拠
```

#### I - インターフェース分離原則（Interface Segregation）

**TDDの促進効果**:
- テストで必要なメソッドのみ定義
- 大きなインターフェース = テストダブル作成が困難

**兆候**:
```markdown
テスト困難: 「このモックには10個のメソッドが必要」
  → インターフェースが大きすぎる

テスト容易: 「このモックには2個のメソッドで十分」
  → インターフェースが適切
```

#### D - 依存性逆転原則（Dependency Inversion）

**TDDの促進効果**:
- テストダブル注入のため具象依存を排除
- 抽象への依存が自然に生まれる

**パターン**:
```markdown
Before（テスト困難）:
  class Service {
    private db = new PostgresDB()  // 具象依存
  }

After（テスト容易）:
  class Service {
    constructor(private db: Database) {}  // 抽象依存
  }
```

---

## Simple Design（シンプル設計）

### ケント・ベックの4つの規則

優先度順に適用します：

#### 1. テストをパスする

**最優先事項**: すべてのテストが成功すること

```markdown
原則:
  - テストは仕様の実行可能な表現
  - テストが通らないコードは完成していない
  - テストは最新の仕様を反映
```

#### 2. 意図を表現する

**コードが何をしているか明確**

```markdown
テクニック:
  - 説明的な命名
  - 適切な抽象化
  - ドメイン用語の使用

例:
  ❌ data.filter(x => x.s > 0)
  ✅ orders.filter(order => order.isActive())
```

#### 3. 重複を排除する

**DRYの適用**

```markdown
対象:
  - コードの重複
  - 知識の重複
  - ロジックの重複

方法:
  - メソッド抽出
  - クラス抽出
  - テンプレート化
```

#### 4. 最小限の要素

**不要なものを含まない**

```markdown
削除対象:
  - 使用されないコード
  - 過剰な抽象化
  - 「将来のため」のコード
```

### 適用順序の重要性

```markdown
1. テストをパス → 動作するコードを確保
2. 意図を表現 → 可読性を確保
3. 重複を排除 → 保守性を確保
4. 最小限の要素 → シンプルさを確保

注意: 1の前に2-4を適用しない
```

---

## テスト可能性が示す設計品質

### テスト困難な設計のシグナル

| シグナル | 設計問題 | 改善方向 |
|---------|---------|---------|
| 多数のモックが必要 | 依存が多すぎる | 責任を分割 |
| セットアップが複雑 | 初期化が複雑 | ファクトリ導入 |
| グローバル状態に依存 | 副作用がある | 純粋関数化 |
| 時間に依存 | 非決定的 | 時間を注入可能に |
| 外部システムに直結 | 密結合 | アダプター導入 |

### テスト容易な設計の特徴

```markdown
1. 依存性注入
   - 外部依存を注入可能
   - テストダブルに置換可能

2. 単一責任
   - 一つのことを上手く行う
   - テストがシンプル

3. インターフェース指向
   - 抽象に依存
   - 実装を差し替え可能

4. 副作用の分離
   - 純粋なロジックを分離
   - 副作用を最小化
```

---

## 設計改善のサイクル

### TDDによる設計改善フロー

```markdown
1. テストを書く
   ↓
2. テストが書きにくい
   ↓
3. 設計の問題を認識
   ↓
4. リファクタリングで改善
   ↓
5. テストが書きやすくなる
   ↓
6. 次のテストへ
```

### 設計改善の兆候

**改善が必要な兆候**:
- テストセットアップが10行以上
- モックが5個以上必要
- テスト名が長くなる
- テストが脆くなる（すぐ壊れる）

**改善完了の兆候**:
- テストセットアップが3行以内
- モックが2-3個で十分
- テスト名が簡潔
- テストが安定

---

## 判断基準チェックリスト

### SOLID準拠

- [ ] 各クラスは単一の責任を持つか？
- [ ] 拡張で機能追加できるか？
- [ ] 派生クラスは基底クラスと置換可能か？
- [ ] インターフェースは最小限か？
- [ ] 抽象に依存しているか？

### Simple Design

- [ ] すべてのテストがパスするか？
- [ ] コードは意図を明確に表現しているか？
- [ ] 重複は排除されているか？
- [ ] 不要な要素はないか？

### テスト可能性

- [ ] 依存性注入が適用されているか？
- [ ] 副作用は分離されているか？
- [ ] グローバル状態への依存はないか？
- [ ] テストダブルに置換可能か？

---

## 参考文献

- Kent Beck『実装パターン』
- Robert C. Martin『アジャイルソフトウェア開発の奥義』
- Michael Feathers『Working Effectively with Legacy Code』
