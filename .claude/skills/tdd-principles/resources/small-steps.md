# 小さなステップの実践

## 概要

TDDの核心原則の一つは「小さなステップで進む」ことです。
大きな変更は小さなステップの連続として実現します。

---

## 原則: 一度に一つのことだけを変更

### なぜ小さなステップか？

1. **失敗の原因が明確**
   - 小さな変更 = 問題の特定が容易
   - 大きな変更 = 何が原因か不明

2. **常にグリーン状態を維持**
   - いつでもコミット可能
   - 中断しても安全

3. **自信を持って進める**
   - 各ステップで検証
   - 不安なく前進

### ステップサイズの指標

- **1つのテストケース = 1つの振る舞い**
- **1つのリファクタリング = 1つの改善**
- **目標: 常にグリーン状態を維持**

---

## 実践パターン

### パターン1: Fake It Till You Make It

**概念**: ハードコードした値でテストを通し、段階的に一般化

**手順**:

```
1. テストを書く
2. ハードコードした値でテストを通す
3. 次のテストを追加
4. ハードコードでは通らなくなる
5. 一般化した実装に変更
6. 繰り返し
```

**例**:

```markdown
Step 1: 最初のテスト
Input: 1 + 1
Expected: 2
実装: return 2 // ハードコード

Step 2: 次のテスト追加
Input: 1 + 2
Expected: 3
実装: return 2 // 失敗

Step 3: 一般化
実装: return a + b
```

**利点**:

- 確実に前進できる
- 過剰な実装を防げる
- 次のステップが明確

### パターン2: Triangulation（三角測量）

**概念**: 複数のテストケースから共通パターンを見出し、一般化

**手順**:

```
1. 最初のテストを書く（単純なケース）
2. ハードコードで通す
3. 別のケースのテストを追加
4. 両方を通す一般化された実装を考える
5. 必要に応じてさらにケースを追加
```

**例**:

```markdown
テスト1: 1 + 1 = 2
テスト2: 2 + 3 = 5
テスト3: 0 + 0 = 0

→ 共通パターン: a + b
```

**使用場面**:

- 一般化の方向が不明確な時
- 複数の解決策が考えられる時
- 確信を持って実装したい時

### パターン3: Obvious Implementation（明白な実装）

**概念**: 実装が明白な場合は直接書く

**条件**:

- 実装方法が明確
- 間違いのリスクが低い
- 経験から自信がある

**注意**:

- 失敗したら「Fake It」に戻る
- 自信過剰は禁物
- テストは必ず通す

**判断基準**:

```
Q: 実装が明白？
├─ Yes → Obvious Implementation
│        └─ 失敗したら？ → Fake Itに戻る
└─ No → Fake It / Triangulation
```

---

## ステップサイズの調整

### ステップが大きすぎる兆候

1. **テストが通らない時間が長い**
   - 目安: 5分以上Red状態
   - 対策: より小さな単位に分割

2. **原因が特定できない**
   - 兆候: 何が問題か分からない
   - 対策: 変更を戻して再開

3. **不安を感じる**
   - 兆候: 「これで合っているか？」
   - 対策: より確実な小さいステップ

### ステップを小さくする方法

1. **中間目標を設定**

   ```
   大きな目標: 認証システム実装

   中間目標:
   - パスワード検証
   - トークン生成
   - トークン検証
   - セッション管理
   ```

2. **境界ケースを分離**

   ```
   一度にすべて:
   - 正常系 + 境界値 + エラー系

   分離:
   - まず正常系
   - 次に境界値
   - 最後にエラー系
   ```

3. **依存を分離**

   ```
   複雑な依存:
   - DB + API + キャッシュ

   分離:
   - まずDB
   - 次にAPI
   - 最後にキャッシュ
   ```

---

## Greenを維持するテクニック

### 1. 変更をコミット可能な状態に保つ

```markdown
悪い例:
機能A実装中 → 機能B開始 → 両方未完成

良い例:
機能A実装 → コミット → 機能B実装 → コミット
```

### 2. 壊れたらすぐに戻る

```markdown
手順:

1. 変更前の状態を覚える
2. 変更を試す
3. 失敗したら即座に戻す
4. より小さいステップで再試行
```

### 3. テストを頻繁に実行

```markdown
タイミング:

- 数行書いたらテスト
- 保存するたびにテスト
- 不安を感じたらテスト
```

---

## 小さなステップのチェックリスト

### テスト作成時

- [ ] 一つのテストで一つの振る舞いのみ検証か？
- [ ] 最も単純なケースから始めているか？
- [ ] テストは5分以内に書けるサイズか？

### 実装時

- [ ] テストを通す最小限の実装か？
- [ ] 一度に複数のテストを通そうとしていないか？
- [ ] 不安を感じたらより小さいステップに戻れるか？

### リファクタリング時

- [ ] 一度に一つの改善のみか？
- [ ] 各ステップ後にテストを実行しているか？
- [ ] 変更をすぐに戻せる状態か？

---

## トラブルシューティング

### 問題: ステップが小さすぎて進まない

**原因**: 過度に慎重

**解決策**:

- Obvious Implementationを試す
- 経験を積んでステップを大きくする
- バランスを見つける

### 問題: どう分割すればいいか分からない

**原因**: 機能の分解が不十分

**解決策**:

- ユースケースを列挙
- 入力と出力を明確化
- 依存関係を整理

### 問題: テストが複雑すぎる

**原因**: テスト対象が大きすぎる

**解決策**:

- テスト対象を分割
- 依存をモック化
- 単一責任を確認

---

## 参考文献

- Kent Beck『テスト駆動開発』Chapter 4: Privacy
- Martin Fowler『Refactoring』Chapter 1: Refactoring, a First Example
