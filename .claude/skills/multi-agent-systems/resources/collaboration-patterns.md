# Collaboration Patterns

## 概要

マルチエージェントシステムにおける4つの協調パターンと適用ガイドライン。

## 4つの協調パターン

### 1. 委譲（Delegation）

**構造**:
```
オーケストレーター
    ├→ ワーカー1
    ├→ ワーカー2
    └→ ワーカー3
```

**特徴**:
- 上位エージェントが下位エージェントにタスクを委譲
- 並行実行可能
- 結果を上位エージェントが統合

**適用ケース**:
- 大きなタスクを複数のサブタスクに分割
- 各サブタスクが独立
- 統合的な結果が必要

**例**:
```yaml
---
name: code-review-orchestrator
description: |
  コードレビューを複数のワーカーに委譲。

  🔴 ワーカーエージェント:
  - style-checker: スタイルチェック
  - security-analyzer: セキュリティ分析
  - performance-profiler: パフォーマンス分析

tools: [Task, Read, Grep]
---
```

**メリット**:
- ✅ 並行処理で高速
- ✅ 責任の明確な分離
- ✅ スケーラブル

**デメリット**:
- ❌ オーケストレーターの複雑性
- ❌ ワーカー間の調整が困難

### 2. 連鎖（Chaining）

**構造**:
```
エージェント1 → エージェント2 → エージェント3
```

**特徴**:
- エージェントが順次処理を引き継ぐ
- 各エージェントは前段の結果を入力として受け取る
- パイプライン形式

**適用ケース**:
- 段階的な変換プロセス
- 各段階が前段の結果に依存
- データフロー形式のワークフロー

**例**:
```yaml
---
name: data-pipeline-orchestrator
description: |
  データ処理パイプライン。

  🔴 パイプラインフロー:
  data-extractor → data-transformer → data-loader
---
```

**ハンドオフ例**:
```json
{
  "from_agent": "data-extractor",
  "to_agent": "data-transformer",
  "status": "completed",
  "artifacts": [".claude/temp/extracted-data.json"],
  "context": {
    "records_extracted": 1500,
    "next_steps": ["Transform to structured format"]
  }
}
```

**メリット**:
- ✅ シンプルで理解しやすい
- ✅ 段階的な処理
- ✅ デバッグが容易

**デメリット**:
- ❌ 順次実行のため遅い
- ❌ エラー発生時の影響が大きい

### 3. 並行（Parallel）

**構造**:
```
エージェント1 ┐
エージェント2 ├→ 統合エージェント
エージェント3 ┘
```

**特徴**:
- 複数エージェントが同時並行で実行
- 結果を統合エージェントがまとめる
- 独立したタスクを並行処理

**適用ケース**:
- 互いに独立したタスク
- 高速化が必要
- 複数の視点からの分析

**例**:
```yaml
---
name: multi-perspective-analyzer
description: |
  複数の視点から並行分析。

  🔴 並行エージェント:
  - performance-analyzer: パフォーマンス視点
  - security-analyzer: セキュリティ視点
  - quality-analyzer: 品質視点
---
```

**メリット**:
- ✅ 最も高速
- ✅ 独立性が高い
- ✅ スケーラビリティ

**デメリット**:
- ❌ 統合の複雑性
- ❌ リソース消費が大きい

### 4. フィードバック（Feedback）

**構造**:
```
エージェント1 ⇄ エージェント2
```

**特徴**:
- エージェント間で双方向の情報交換
- 反復的な改善プロセス
- 相互依存的な関係

**適用ケース**:
- 反復的な改善が必要
- 相互の専門知識を活用
- 品質向上プロセス

**例**:
```yaml
---
name: iterative-refinement-system
description: |
  反復的改善システム。

  🔴 フィードバックループ:
  code-generator ⇄ code-reviewer
  （生成 → レビュー → 改善 → レビュー...）
---
```

**メリット**:
- ✅ 高品質な結果
- ✅ 反復的改善
- ✅ 専門知識の相互活用

**デメリット**:
- ❌ 実行時間が長い
- ❌ 無限ループのリスク
- ❌ 複雑性が高い

## パターン選択マトリックス

| 条件 | 推奨パターン | 理由 |
|------|------------|------|
| タスクが独立している | 委譲 or 並行 | 並行処理可能 |
| タスクが依存関係にある | 連鎖 | 順次処理が必要 |
| 高速化が最優先 | 並行 | 同時実行で最速 |
| 品質が最優先 | フィードバック | 反復改善で高品質 |
| タスク数が多い（>5） | 委譲 | スケーラブル |
| 段階的変換が必要 | 連鎖 | パイプライン形式 |

## 組み合わせパターン

### ハイブリッド: 委譲 + 連鎖

```
オーケストレーター
    ├→ ワーカーA → ワーカーB
    ├→ ワーカーC → ワーカーD
    └→ ワーカーE
```

**適用ケース**: 大規模プロジェクトで並行処理と順次処理の両方が必要

### ハイブリッド: 並行 + フィードバック

```
エージェント1 ⇄ レビューアー
エージェント2 ⇄ レビューアー
エージェント3 ⇄ レビューアー
```

**適用ケース**: 複数の実装を並行生成し、共通のレビューアーが改善フィードバック

## ベストプラクティス

### ✅ すべきこと

1. **明確なハンドオフプロトコル**: 標準フォーマット使用
2. **エラーハンドリング**: 各パターンに適した処理
3. **タイムアウト設定**: 無限ループ防止（特にフィードバック）
4. **依存関係の文書化**: 明示的な依存関係記述
5. **モニタリング**: 進捗状況の可視化

### ❌ 避けるべきこと

1. **循環依存**: エージェント間の循環参照
2. **過度な並行**: リソース枯渇
3. **無限フィードバック**: 終了条件なし
4. **曖昧なハンドオフ**: 非標準フォーマット
5. **エラーハンドリング不足**: 障害時の対応なし

## 変更履歴

| バージョン | 日付 | 変更内容 |
|-----------|------|---------|
| 1.0.0 | 2025-11-24 | 初版作成 |
