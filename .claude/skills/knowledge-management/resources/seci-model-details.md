# SECIモデル詳細ガイド

## 概要

SECIモデル（Socialization-Externalization-Combination-Internalization）は、
野中郁次郎が提唱した組織における知識創造の理論的フレームワークです。
暗黙知と形式知の相互変換を通じて、組織全体の知識が創造・共有・活用されます。

## SECIサイクルの4つのモード

### 1. Socialization（共同化）: 暗黙知→暗黙知

**定義**: 経験の共有、観察、模倣による暗黙知の伝達

**Claude Codeエコシステムでの適用**:

- コードレビューでの指摘内容の収集
- チーム内議論の記録
- 専門家の実践パターンの観察
- 頻出する問題とその解決方法の抽出

**実践方法**:

1. **情報源の特定**:
   - [ ] コードレビューコメント履歴
   - [ ] Slackやissueでの議論
   - [ ] ペアプログラミングでの気づき
   - [ ] 専門家の作業プロセス

2. **暗黙知の収集**:
   - 具体的な事例の記録
   - 判断プロセスの観察
   - パターンの仮説立て

3. **共有と対話**:
   - チーム内での議論
   - 経験の言語化への試み
   - フィードバックの収集

**判断基準**:

- [ ] 暗黙知の源泉が明確か？
- [ ] 十分な事例が集まっているか？
- [ ] パターンが見えてきているか？

**成果物**: 生の情報（レビューコメント集、議論メモ、事例集）

---

### 2. Externalization（表出化）: 暗黙知→形式知

**定義**: 対話や内省により暗黙知を言語化、概念化、文書化

**Claude Codeエコシステムでの適用**:

- レビュー指摘を原則やチェックリストに変換
- 経験則を判断基準として明文化
- 実践ノウハウをSKILL.mdに形式知化

**実践方法**:

1. **言語化**:
   - 暗黙的な判断を言葉で表現
   - 「なぜそう判断したか」の自問
   - 概念の抽象化と命名

2. **概念化**:
   - パターンの抽出
   - カテゴリ分類
   - 原則の定義

3. **体系化**:
   - チェックリスト化
   - 判断基準の明確化
   - 階層構造の設計

**言語化のテクニック**:

**テクニック1: 事例からの抽象化**

```
具体例:
「このコンポーネントは状態管理と表示ロジックが混在している」

抽象化:
原則: 関心の分離（Separation of Concerns）
判断基準:
- [ ] 状態管理ロジックと表示ロジックが分離されているか？
- [ ] 各レイヤーの責務が明確か？
```

**テクニック2: Why分析（5回のなぜ）**

```
Q1: なぜこのコードは問題か？
A1: コンポーネントの責務が曖昧だから

Q2: なぜ責務が曖昧だと問題か？
A2: 変更時の影響範囲が予測できないから

Q3: なぜ影響範囲を予測可能にする必要があるか？
A3: 保守性を高めるため

→ 原則: 単一責任原則（SRP）の適用
```

**テクニック3: チェックリスト変換**

```
暗黙的判断:
「なんとなくこの設計は複雑すぎる」

明示的チェックリスト:
- [ ] 1つのファイルが300行を超えていないか？
- [ ] 1つの関数が50行を超えていないか？
- [ ] 循環的複雑度が10を超えていないか？
- [ ] ネストが3階層を超えていないか？
```

**判断基準**:

- [ ] 暗黙知が明示的な言語で表現されているか？
- [ ] 他者が再現可能な形式になっているか？
- [ ] 抽象的すぎず、具体的すぎない適切な粒度か？
- [ ] 検証可能な基準が含まれているか？

**アンチパターン**:

- ❌ 「良い設計をする」（曖昧）
- ❌ 「適切に実装する」（主観的）
- ✅ 「単一責任原則に従い、1つのクラスは1つの変更理由のみを持つ」（明確）

**成果物**: 形式知化された知識（原則、チェックリスト、判断基準）

---

### 3. Combination（連結化）: 形式知→形式知

**定義**: 複数の形式知を組み合わせて新しい知識体系を構築

**Claude Codeエコシステムでの適用**:

- 複数情報源（書籍、ドキュメント、経験）の統合
- 既存スキルとの関連性の明確化
- 知識の階層化とリソース分割

**実践方法**:

1. **情報源の統合**:
   - 公式ドキュメント
   - 書籍の理論
   - チームの実践経験
   - 既存スキル・ガイドライン

2. **矛盾の解消**:
   - 情報源間の不一致を特定
   - より信頼性の高い情報源を優先
   - コンテキスト依存の使い分けを明示

3. **体系化**:
   - 階層構造の設計
   - トピック別分類
   - 参照関係の整理
   - Progressive Disclosure適用

**統合パターン**:

**パターン1: 階層的統合**

```
レベル1: 概要（SKILL.md）
├─ レベル2: 基本的な知識（resources/basics.md）
├─ レベル3: 応用的な知識（resources/advanced.md）
└─ レベル4: 特殊ケース（resources/edge-cases.md）
```

**パターン2: トピック別統合**

```
トピック1: 設計原則（resources/design-principles.md）
トピック2: 実装パターン（resources/implementation-patterns.md）
トピック3: テスト戦略（resources/testing-strategies.md）
```

**パターン3: 情報源別統合**

```
公式ドキュメント: 標準的な実装方法
書籍の理論: 設計原則と背景
チームの実践: プロジェクト固有の適用方法

→ 統合: 標準 + 理論的背景 + 実践例
```

**判断基準**:

- [ ] 知識が体系的に整理されているか？
- [ ] 重複が排除されているか？
- [ ] 参照関係が明確か？
- [ ] 矛盾が解消されているか？

**成果物**: 統合された知識体系（SKILL.md + リソースファイル群）

---

### 4. Internalization（内面化）: 形式知→暗黙知

**定義**: 形式知を実践し、身体知として内面化

**Claude Codeエコシステムでの適用**:

- スキルを実際のタスクで活用
- フィードバックによる改善
- エージェントの実行を通じた知識の洗練

**実践方法**:

1. **実践**:
   - スキルをタスクに適用
   - チェックリストに従って実行
   - 判断基準で評価

2. **フィードバック収集**:
   - 使いやすさの評価
   - 不足している情報の特定
   - 誤りや曖昧性の発見

3. **継続的改善**:
   - スキルの更新
   - バージョニング
   - 変更履歴の記録

**フィードバックループ**:

```
実践 → 気づき → 形式知の改善 → 再実践
  ↑                              ↓
  └──────────────────────────────┘
```

**陳腐化検出**:

- [ ] 最終更新から6ヶ月以上経過？
- [ ] 参照する技術のバージョンが古い？
- [ ] 非推奨のAPIやパターンを含む？
- [ ] エージェントからの参照頻度が低下？

**更新プロセス**:

1. 陳腐化検出
2. 更新内容の評価
3. バージョン番号の決定（major.minor.patch）
4. 変更履歴の記録
5. 後方互換性の確認

**判断基準**:

- [ ] 実践で使われているか？
- [ ] フィードバックが反映されているか？
- [ ] 継続的な改善サイクルが機能しているか？

**成果物**: 洗練された形式知、実践を通じた暗黙知の蓄積

---

## SECIサイクルの回転

SECIモデルは一回限りのプロセスではなく、継続的に回転するサイクルです:

```
Socialization → Externalization → Combination → Internalization
      ↑                                              ↓
      └──────────────────────────────────────────────┘
         （実践で得た新しい暗黙知を再度形式知化）
```

**サイクル回転の例（コードレビュー知識）**:

**第1サイクル**:

1. S: レビューコメントを収集
2. E: 「単一責任原則」のチェックリスト作成
3. C: 既存の設計原則ドキュメントに統合
4. I: レビューで実践、フィードバック収集

**第2サイクル**:

1. S: 実践で得た新しい気づき（特定のパターンでSRPが曖昧）
2. E: より具体的な判断基準を追加
3. C: チェックリストを拡張
4. I: 再実践、さらに洗練

**継続的改善の指標**:

- サイクル回転回数
- バージョン更新頻度
- フィードバック反映率

---

## Claude Codeエコシステムへの適用指針

### スキル作成時のSECIサイクル

**Phase 1 - Socialization**:

- 既存スキルの調査
- ドキュメントの読み込み
- コードパターンの抽出

**Phase 2 - Externalization**:

- スキルの設計
- YAML Frontmatter作成
- SKILL.md本文の記述

**Phase 3 - Combination**:

- リソースファイルの統合
- 既存スキルとの関連性明示
- Progressive Disclosure適用

**Phase 4 - Internalization**:

- エージェントによる実践
- フィードバック収集
- バージョン更新

### エージェント設計時のSECIサイクル

**Phase 1 - Socialization**:

- 専門家のペルソナ定義
- 参照書籍・メソッドの調査
- 既存エージェントの分析

**Phase 2 - Externalization**:

- 役割と責務の明文化
- ツール選択基準の定義
- ワークフローの設計

**Phase 3 - Combination**:

- スキル参照の統合
- コマンド連携の設計
- エージェント間協調の定義

**Phase 4 - Internalization**:

- 実タスクでの実行
- 品質評価
- 継続的改善

---

## 実践的なヒント

### 暗黙知の発見方法

1. **頻度分析**: 同じ指摘が3回以上→形式知化の候補
2. **Why分析**: 5回のなぜで根本原則を抽出
3. **パターン認識**: 類似事例をグループ化

### 形式知化の品質基準

- **完全性**: 必要な情報がすべて含まれている
- **明確性**: 理解しやすい言葉で表現
- **再現性**: 他者が同じ結果を得られる
- **検証可能性**: 判断基準が測定可能

### 知識の陳腐化防止

- 6ヶ月ごとのレビューサイクル
- バージョニングによる変更追跡
- 参照頻度のモニタリング

## 参考文献

- **『知識創造企業』** 野中郁次郎・竹内弘高著
  - 第3章: 知識創造の理論（SECIモデルの詳細）
  - 第4章: 知識を創造するプロセス

- **『ナレッジマネジメント』** 野中郁次郎他著
  - SECIモデルの実践的適用方法
