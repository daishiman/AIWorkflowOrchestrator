# 知識の鮮度維持戦略

## 概要

知識は時間とともに陳腐化します。技術の進化、ベストプラクティスの変化、プロジェクト要件の変更により、
一度形式知化した知識も継続的な更新が必要です。この戦略により、知識ベースの鮮度を維持し、
信頼性の高い情報を提供し続けることができます。

## 陳腐化の兆候

### 技術的陳腐化

**兆候1: バージョンの不一致**
- [ ] 参照する技術のバージョンが現在の使用バージョンと異なる
- [ ] 非推奨(deprecated)のAPIやパターンを含む
- [ ] 新しいメジャーバージョンの機能を反映していない

**例**:
```
陳腐化した知識: "React 16でのライフサイクルメソッド"
現状: React 18を使用中、HooksとConcurrent Featuresが主流
```

**兆候2: セキュリティリスク**
- [ ] 既知の脆弱性を含むパターンを推奨している
- [ ] セキュリティベストプラクティスが更新されていない
- [ ] 最新のセキュリティ標準に準拠していない

### 組織的陳腐化

**兆候3: プロジェクトとの不整合**
- [ ] プロジェクトの技術スタックが変更されている
- [ ] プロジェクトのアーキテクチャ原則が更新されている
- [ ] チームのスキルセットが変化している

**兆候4: 利用状況の変化**
- [ ] 参照頻度が急激に低下している
- [ ] エージェントからのフィードバックで問題が報告されている
- [ ] 実践で使われなくなっている

### 内容的陳腐化

**兆候5: 情報の不完全性**
- [ ] 新しいユースケースに対応していない
- [ ] エッジケースの情報が不足している
- [ ] トラブルシューティング情報が古い

**兆候6: 表現の曖昧性**
- [ ] 判断基準が不明確になっている
- [ ] チェックリストが不完全である
- [ ] 例が実態と乖離している

---

## 陳腐化検出メカニズム

### 自動検出

**検出方法1: 時間ベース**
```bash
# 最終更新日をチェック
# scripts/check-staleness.sh

MAX_AGE_DAYS=180  # 6ヶ月

for file in .claude/skills/*/SKILL.md; do
    last_updated=$(grep "最終更新:" "$file" | sed 's/.*: //')
    age_days=$(calculate_age "$last_updated")

    if [ $age_days -gt $MAX_AGE_DAYS ]; then
        echo "STALE: $file ($age_days days old)"
    fi
done
```

**検出方法2: バージョンチェック**
```bash
# 参照する技術のバージョンをチェック
# package.jsonと比較して古いバージョン参照を検出

grep -r "React 16" .claude/skills/ # React 16の参照を検出
grep -r "Node 14" .claude/skills/  # Node 14の参照を検出
```

**検出方法3: 非推奨APIの検出**
```bash
# 非推奨APIの参照をチェック
grep -r "componentWillMount" .claude/skills/  # React非推奨メソッド
grep -r "request.isUnauthenticated" .claude/skills/  # 廃止されたAPI
```

### 手動検出

**検出方法4: 定期レビュー**
```markdown
## 定期レビューチェックリスト

### 技術的妥当性
- [ ] 参照する技術のバージョンは最新の推奨版か？
- [ ] 使用しているAPIはすべて有効か？
- [ ] セキュリティベストプラクティスは最新か？

### 内容の完全性
- [ ] 新しいユースケースに対応しているか？
- [ ] トラブルシューティングは十分か？
- [ ] 例は現在のプロジェクトに適合しているか？

### 実用性
- [ ] 実際に使われているか（参照頻度）？
- [ ] フィードバックで問題は報告されていないか？
- [ ] 判断基準は明確で実践可能か？
```

**検出方法5: フィードバック収集**
```
エージェント実行時のフィードバック収集:
- 「この知識は役立ったか？」
- 「不足している情報はないか？」
- 「誤りや古い情報はないか？」
```

---

## 更新戦略

### 更新優先順位

**優先度: 高（即座に更新）**
- セキュリティ脆弱性を含む知識
- 非推奨APIを推奨している知識
- プロジェクトの技術スタックと不整合な知識
- 参照頻度が高く、問題が報告されている知識

**優先度: 中（四半期内に更新）**
- 最終更新から6ヶ月以上経過した知識
- 新しいベストプラクティスが出現した領域
- 参照頻度が中程度の知識

**優先度: 低（半年以内に更新）**
- 普遍的な原則に関する知識（変化が少ない）
- 参照頻度が低い知識
- 軽微な改善提案がある知識

### 更新プロセス

#### ステップ1: 陳腐化評価

**評価フォーム**:
```markdown
## 陳腐化評価: [知識タイトル]

### 技術的側面
- バージョン整合性: [OK / 要更新 / 不明]
- API有効性: [OK / 非推奨あり / 廃止あり]
- セキュリティ: [OK / 要確認 / リスクあり]

### 内容的側面
- 完全性: [十分 / 一部不足 / 大幅不足]
- 明確性: [明確 / 一部曖昧 / 不明確]
- 実用性: [高い / 中程度 / 低い]

### 利用状況
- 参照頻度: [高 / 中 / 低]
- 最終参照日: YYYY-MM-DD
- フィードバック: [肯定的 / 中立 / 否定的]

### 総合判定
- [ ] 更新不要（現状維持）
- [ ] 軽微な更新（Patch）
- [ ] 機能追加（Minor）
- [ ] 大幅な改訂（Major）
```

#### ステップ2: 更新内容の設計

**Patch更新 (1.0.0 → 1.0.1)**:
- タイポ修正
- リンク修正
- 軽微な表現の改善

**Minor更新 (1.0.0 → 1.1.0)**:
- 新しい例の追加
- トラブルシューティング項目の追加
- 既存内容の詳細化（既存の使い方は引き続き有効）

**Major更新 (1.0.0 → 2.0.0)**:
- 技術スタックの変更（React 16 → 18等）
- 原則や推奨パターンの大幅な変更
- 構造の全面的な再設計

#### ステップ3: 更新の実施

**更新手順**:
1. **バックアップ**: 現在のバージョンをコピー保存
2. **更新**: 必要な変更を実施
3. **検証**:
   - [ ] 構文エラーがないか
   - [ ] リンクが有効か
   - [ ] 例が動作するか
4. **バージョニング**: セマンティックバージョニングに従う
5. **変更履歴**: 詳細な変更内容を記録

**変更履歴の記録例**:
```markdown
| バージョン | 日付 | 変更内容 |
|-----------|------|---------|
| 2.0.0 | 2025-11-23 | Major: React 18対応、Concurrent Features追加 |
| 1.2.0 | 2025-09-15 | Minor: useTransition hookの例を追加 |
| 1.1.1 | 2025-08-20 | Patch: タイポ修正、リンク更新 |
| 1.1.0 | 2025-07-10 | Minor: トラブルシューティングセクション拡充 |
| 1.0.0 | 2025-06-01 | 初版作成 |
```

#### ステップ4: 後方互換性の確認

**互換性チェックリスト**:
- [ ] 既存のエージェントが引き続き機能するか？
- [ ] 既存の参照パスが有効か？
- [ ] 既存のチェックリストが引き続き使えるか？
- [ ] 大きな変更の場合、移行ガイドを提供したか？

**移行ガイドの例**:
```markdown
## 移行ガイド: v1.x → v2.0

### 破壊的変更
1. **ライフサイクルメソッド → Hooks**
   - 旧: componentDidMount
   - 新: useEffect(() => {}, [])

2. **Context API**
   - 旧: Context.Consumer
   - 新: useContext hook

### 移行手順
1. 既存コードのバックアップ
2. Hooksへの段階的移行
3. テストの実行
4. 旧パターンの削除
```

---

## 更新サイクル

### 定期レビュースケジュール

**月次レビュー** (参照頻度Top 20%):
- 対象: 最も頻繁に参照される知識
- 実施タイミング: 毎月初旬
- 所要時間: 2-3時間
- 担当: @skill-librarian

**四半期レビュー** (参照頻度Middle 60%):
- 対象: 一般的に参照される知識
- 実施タイミング: 四半期末
- 所要時間: 1日
- 担当: @skill-librarian + 関連エージェント

**半年レビュー** (参照頻度Bottom 20%):
- 対象: 稀に参照される知識
- 実施タイミング: 半年ごと
- 所要時間: 半日
- 担当: @skill-librarian

**緊急レビュー**:
- トリガー: セキュリティ脆弱性発見、重大なバグ報告
- 実施タイミング: 即座
- 担当: @skill-librarian（最優先対応）

### イベント駆動更新

**トリガー1: 技術スタックのアップデート**
```
プロジェクトのpackage.json更新
→ 影響を受ける知識を特定
→ 優先順位付け
→ 順次更新
```

**トリガー2: セキュリティアドバイザリ**
```
pnpm audit結果
→ 脆弱性を含む知識を特定
→ 即座に更新
→ チーム全体に通知
```

**トリガー3: ベストプラクティスの変化**
```
公式ドキュメントの大幅更新
→ 関連知識をレビュー
→ 必要に応じて更新
→ 変更を周知
```

---

## 陳腐化予防策

### 設計時の予防

**予防策1: 普遍的な原則を中心に**
```
❌ 具体的な実装: "React 16.8のuseEffectを使う"
✅ 普遍的な原則: "副作用は適切なライフサイクルで管理する"
```

**予防策2: バージョン依存を最小化**
```
❌ バージョン固定: "Next.js 13.4.0以降"
✅ 機能ベース: "App Routerをサポートするバージョン"
```

**予防策3: 抽象度の適切な調整**
```
過度に具体的: 陳腐化が早い
過度に抽象的: 実用性が低い
適切な抽象度: 原則 + 判断基準 + 例
```

### 運用時の予防

**予防策4: フィードバックループの確立**
```
エージェント実行
→ フィードバック収集
→ 問題の早期発見
→ 迅速な更新
```

**予防策5: 自動監視の導入**
```
週次: 陳腐化スクリプト実行
月次: 参照頻度レポート
四半期: 総合品質レポート
```

**予防策6: 知識の階層化**
```
レベル1: 普遍的な原則（変化が遅い）
レベル2: 一般的なパターン（変化が中程度）
レベル3: 具体的な実装（変化が速い）

→ レベル3を最小限に抑え、適切に分離
```

---

## メトリクスと KPI

### 鮮度メトリクス

**メトリクス1: 平均経過日数**
```
平均経過日数 = Σ(各知識の最終更新からの日数) / 総知識数

目標: <90日（3ヶ月以内）
```

**メトリクス2: 陳腐化率**
```
陳腐化率 = (6ヶ月以上更新されていない知識数 / 総知識数) × 100

目標: <10%
```

**メトリクス3: 更新頻度**
```
月次更新率 = (当月更新された知識数 / 総知識数) × 100

目標: >5%（月に5%以上が更新される）
```

### 品質維持メトリクス

**メトリクス4: フィードバックスコア**
```
平均スコア = Σ(各知識のフィードバックスコア) / 評価された知識数

目標: >8/10
```

**メトリクス5: 参照頻度の維持**
```
参照頻度変化率 = (今期の参照数 - 前期の参照数) / 前期の参照数 × 100

目標: >-10%（10%以上の減少なし）
```

---

## ツールと自動化

### 陳腐化検出スクリプト

**スクリプト**: `scripts/check-staleness.sh`
```bash
#!/bin/bash
# 陳腐化した知識を検出

MAX_AGE_DAYS=180
find .claude/skills -name "SKILL.md" -o -name "*.md" | while read file; do
    # 最終更新日を抽出し、経過日数を計算
    # 閾値を超えたものをレポート
done
```

### 更新支援ツール

**スクリプト**: `scripts/update-knowledge.sh`
```bash
#!/bin/bash
# 知識の更新を支援

# バックアップ作成
# バージョン番号の提案
# 変更履歴のテンプレート生成
```

### レポート生成

**スクリプト**: `scripts/generate-freshness-report.sh`
```bash
#!/bin/bash
# 鮮度レポートを生成

# 陳腐化した知識のリスト
# 更新推奨の知識
# メトリクスサマリー
```

---

## ベストプラクティス

### 更新時
1. **小さく頻繁に**: 大きな変更を溜め込まず、小さな変更を頻繁に
2. **バージョニング遵守**: セマンティックバージョニングを厳格に適用
3. **変更履歴を詳細に**: なぜ変更したかを明記

### 設計時
1. **普遍性を優先**: 変化の遅い原則を中心に設計
2. **適切な抽象度**: 具体と抽象のバランス
3. **階層化**: 変化の速度に応じた階層設計

### 運用時
1. **定期レビュー**: スケジュールを守る
2. **自動化**: 可能な検出は自動化
3. **フィードバック活用**: エージェントからの情報を重視

---

## 参考文献

- **『知識創造企業』** 野中郁次郎・竹内弘高著
  - 第6章: 知識創造を支援する情報技術

- **『Building a Second Brain』** Tiago Forte著
  - Part 3: Making Things Happen - 知識の継続的メンテナンス
