# Decompose Conditional

## 概要

複雑な条件式を、意図を明確に表現するメソッドに分解するリファクタリング技法です。
条件の「何を」ではなく「なぜ」を伝えることで、コードの可読性を大幅に向上させます。

## 適用条件

- [ ] 条件式に&&/||が3つ以上含まれる
- [ ] ネストが3段階以上ある
- [ ] 条件の意図がコードから読み取りにくい
- [ ] 同じ条件パターンが複数箇所で使用される

## 手順

### Step 1: 条件部分の抽出

条件式を意味のあるメソッドに抽出する。

**命名のコツ**:

- 状態を表す名前（isValid, hasPermission）
- 判定内容を表す名前（shouldProcess, canExecute）

### Step 2: then節の抽出

条件がtrueの場合の処理を別メソッドに抽出する。

### Step 3: else節の抽出

条件がfalseの場合の処理を別メソッドに抽出する。

### Step 4: テスト実行

各ブランチが正しく動作することを確認する。

## パターン別対処法

### パターン1: 複合条件

複数の条件が&&/||で結合されている場合

**対処**:

- 関連する条件をグループ化
- 各グループを意味のあるメソッドに抽出
- メソッド名で条件の意図を表現

### パターン2: ネストした条件

if文の中にif文がある場合

**対処**:

- ガード節（Guard Clause）への変換を検討
- 早期リターンで深いネストを解消
- 各レベルを独立したメソッドに分割

### パターン3: 複数のelse-if

switch文のような連続条件

**対処**:

- Replace Conditional with Polymorphismを検討
- Strategy Patternへの変換を検討
- 各ブランチをメソッド化して意図を明確に

## ガード節への変換

### 適用基準

- 正常系が一つ、異常系が複数ある場合
- 早期リターンで複雑さを軽減できる場合

### 変換パターン

**ネストした条件** → **ガード節による平坦化**:

- 異常ケースを先に処理してreturn
- 正常ケースをメソッドの最後に配置
- ネストを解消して読みやすく

## 判断基準チェックリスト

### 分解すべきか？

- [ ] 条件式が1行で読みにくいか？
- [ ] 条件の意図を説明するコメントが必要か？
- [ ] 同じ条件パターンが他にもあるか？
- [ ] then/else節が5行を超えるか？

### 分解方法の選択

- [ ] 単純な条件抽出で十分か？
- [ ] ガード節への変換が適切か？
- [ ] Polymorphismが適切か？
- [ ] Strategy Patternが適切か？

## アンチパターン

### 過度な分解

**問題**: 2-3行の単純な条件まで分解して逆に複雑化

**対処**: 分解による可読性向上を常に評価

### 不適切な命名

**問題**: check(), evaluate()などの曖昧な名前

**対処**: isX, hasX, canX, shouldXなど具体的な名前を使用

### 粒度の不統一

**問題**: 一部だけ分解して一貫性がない

**対処**: 同じ抽象度レベルで統一して分解

## 関連リファクタリング

- **Replace Conditional with Polymorphism**: 型による分岐をポリモーフィズムに
- **Replace Nested Conditional with Guard Clauses**: ネストをガード節に
- **Introduce Special Case**: 特殊ケースを専用オブジェクトに
