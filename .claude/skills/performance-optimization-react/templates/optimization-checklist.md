# パフォーマンス最適化チェックリスト

## Phase 1: 問題特定

### 測定

- [ ] React DevTools Profilerをインストール済み
- [ ] 開発モードで実行
- [ ] 「Record why each component rendered」をON
- [ ] 最適化前の測定を実施
- [ ] レンダリング時間を記録（\_\_\_ms）
- [ ] 再レンダリング回数を記録（\_\_\_回）
- [ ] ボトルネックを特定（コンポーネント名: **\_\_\_**）

### 原因分析

- [ ] 再レンダリングの原因を特定
  - [ ] 親の再レンダリング
  - [ ] Contextの値変更
  - [ ] Propsの変更
  - [ ] 状態の更新
- [ ] 最も影響が大きい原因を特定
- [ ] 複数の原因がある場合、優先順位を決定

## Phase 2: 最適化戦略

### 戦略選択

- [ ] 最適化手法を選択
  - [ ] React.memo（親の再レンダリング対策）
  - [ ] useCallback（コールバックProps対策）
  - [ ] useMemo（計算コスト削減）
  - [ ] Context分割（Context更新対策）
- [ ] 実装の優先順位を決定
  - [ ] 高優先度: レンダリング時間100ms以上
  - [ ] 中優先度: 再レンダリング回数10回以上
  - [ ] 低優先度: 境界線上（50-100ms、5-10回）

### 実装計画

- [ ] 最適化対象コンポーネントをリスト化
- [ ] 各コンポーネントの最適化手法を決定
- [ ] 実装順序を決定
- [ ] 必要なリファクタリングを確認

## Phase 3: React.memo適用

### 適用前確認

- [ ] パフォーマンス問題を測定で確認済み
- [ ] Propsが変わらないことが多い
- [ ] レンダリングコストが高い（10ms以上）
- [ ] 親の再レンダリングで不要に子が再レンダリング

### 実装

- [ ] React.memoを適用
- [ ] 必要に応じてカスタム比較関数を実装
- [ ] Propsの変更を確認（React DevTools）

### 検証

- [ ] React DevTools Profilerで測定
- [ ] 再レンダリング回数が削減されたか確認
- [ ] レンダリング時間が削減されたか確認
- [ ] 副作用や新しい問題なし

## Phase 4: useCallback適用

### 適用前確認

- [ ] コールバック関数を子コンポーネントに渡している
- [ ] 子コンポーネントがReact.memoでメモ化されている
- [ ] コールバックが毎回新しい関数として生成されている

### 実装

- [ ] useCallbackを適用
- [ ] 依存配列を正確に指定
- [ ] ESLint exhaustive-depsルール準拠

### 検証

- [ ] React DevTools Profilerで測定
- [ ] 子コンポーネントの再レンダリングが削減されたか確認
- [ ] 依存配列が正確か確認
- [ ] 副作用や新しい問題なし

## Phase 5: useMemo適用

### 適用前確認

- [ ] 計算コストの高い処理がある
- [ ] 計算結果が毎回同じになることが多い
- [ ] レンダリング毎に計算が実行されている

### 実装

- [ ] useMemoを適用
- [ ] 依存配列を正確に指定
- [ ] ESLint exhaustive-depsルール準拠

### 検証

- [ ] React DevTools Profilerで測定
- [ ] 計算が毎回実行されていないか確認
- [ ] レンダリング時間が削減されたか確認
- [ ] 副作用や新しい問題なし

## Phase 6: Context分割

### 分割前確認

- [ ] Contextに複数の値が含まれている
- [ ] 一部の値のみが頻繁に更新される
- [ ] Context使用コンポーネントが10個以上
- [ ] 不要な再レンダリングが測定で確認済み

### 実装

- [ ] 分割パターンを選択
  - [ ] 読み取り専用と書き込み可能の分離
  - [ ] 更新頻度による分離
  - [ ] ドメインによる分離
- [ ] 新しいContextを作成
- [ ] Providerコンポーネントを実装
- [ ] カスタムフックを実装

### 検証

- [ ] React DevTools Profilerで測定
- [ ] 不要な再レンダリングが削減されたか確認
- [ ] レンダリング時間が削減されたか確認
- [ ] 副作用や新しい問題なし

## Phase 7: 効果測定

### 測定データ

- [ ] 最適化後の測定を実施
- [ ] 最適化前後で同じ操作を実行
- [ ] レンダリング時間を記録（\_\_\_ms）
- [ ] 再レンダリング回数を記録（\_\_\_回）
- [ ] コミット時間を記録（\_\_\_ms）

### 改善率計算

- [ ] レンダリング時間削減率を計算（\_\_\_\_%）
  - 目標: 50%以上
- [ ] 再レンダリング回数削減率を計算（\_\_\_\_%）
  - 目標: 70%以上
- [ ] 体感パフォーマンスの改善を確認

### レポート作成

- [ ] 最適化対象を記載
- [ ] 最適化前のデータを記載
- [ ] 最適化内容を記載
- [ ] 最適化後のデータを記載
- [ ] 改善率を記載
- [ ] 結論を記載

## Phase 8: 品質保証

### コード品質

- [ ] TypeScript型チェックをパス
- [ ] ESLint exhaustive-depsルール準拠
- [ ] @ts-ignoreや@ts-expect-errorを使用していない
- [ ] 依存配列は正確

### パフォーマンス

- [ ] React DevTools Profilerで測定済み
- [ ] 目標削減率を達成
  - [ ] レンダリング時間: 50%以上削減
  - [ ] 再レンダリング回数: 70%以上削減
- [ ] 副作用や新しい問題なし

### ドキュメンテーション

- [ ] 最適化内容を文書化
- [ ] 測定結果を記録
- [ ] 注意事項を記載
- [ ] 今後のメンテナンスガイドを作成

### レビュー

- [ ] コードレビュー完了
- [ ] パフォーマンステスト完了
- [ ] チーム承認取得

## 最終確認

### パフォーマンス指標

- [ ] レンダリング時間: \_\_\_ms（目標: 100ms以下）
- [ ] 再レンダリング回数: \_\_\_回（目標: 単一操作あたり3回以下）
- [ ] コミット時間: \_\_\_ms（目標: 16ms以下）
- [ ] 体感パフォーマンス: ユーザー体験の改善を確認

### ベストプラクティス

- [ ] 測定に基づいて最適化した
- [ ] 早すぎる最適化を避けた
- [ ] React.memoは測定に基づいて適用
- [ ] useCallbackとuseMemoの依存配列は正確
- [ ] Context分割は適切な粒度
- [ ] 副作用や新しい問題なし

### デプロイ準備

- [ ] 本番環境でのテスト完了
- [ ] ロールバックプラン作成
- [ ] モニタリング設定完了
- [ ] デプロイ承認取得

---

## 測定データテンプレート

### 最適化前

```
コンポーネント: _______________________
操作: _______________________

レンダリング時間: ___ms
再レンダリング回数: ___回
コミット時間: ___ms

ボトルネック:
- _______________________
- _______________________
```

### 最適化後

```
コンポーネント: _______________________
操作: _______________________

レンダリング時間: ___ms (____%削減)
再レンダリング回数: ___回 (____%削減)
コミット時間: ___ms (____%削減)

最適化内容:
- _______________________
- _______________________
```

## 改善率計算式

```
改善率 = (最適化前 - 最適化後) / 最適化前 × 100%

例:
レンダリング時間: (120ms - 40ms) / 120ms × 100% = 66.7%
再レンダリング回数: (15回 - 3回) / 15回 × 100% = 80%
```
