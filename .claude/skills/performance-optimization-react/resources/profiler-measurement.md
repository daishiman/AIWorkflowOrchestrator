# React DevTools Profiler 測定方法

## Profilerの概要

React DevTools Profilerは、Reactアプリケーションのレンダリングパフォーマンスを測定・分析するツールです。
各コンポーネントのレンダリング時間、回数、原因を可視化できます。

## インストールと設定

### ブラウザ拡張機能のインストール

1. **Chrome**: [Chrome Web Store](https://chrome.google.com/webstore/detail/react-developer-tools/)
2. **Firefox**: [Firefox Add-ons](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/)
3. **Edge**: [Microsoft Edge Add-ons](https://microsoftedge.microsoft.com/addons/detail/react-developer-tools/)

### 開発環境の設定

```json
// package.json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  }
}
```

**注意**: Profilerは開発モードで使用してください。本番ビルドでは一部の機能が無効化されます。

## 基本的な測定手順

### ステップ1: Profilerを開く

1. ブラウザの開発者ツールを開く（F12またはCmd+Opt+I）
2. 「Profiler」タブを選択
3. 設定アイコン（⚙️）で測定オプションを確認

### ステップ2: 記録開始

1. 青い記録ボタン（●）をクリック
2. 最適化したい操作を実行
3. 記録停止ボタン（■）をクリック

### ステップ3: 結果の分析

記録が完了すると、以下の3つのビューで結果を確認できます:

1. **Flamegraph**: 各コンポーネントのレンダリング時間を視覚化
2. **Ranked**: レンダリング時間の長い順にソート
3. **Component**: 特定コンポーネントの詳細

## Flamegraphビューの使い方

### 基本的な見方

```
Parent (15ms)
├── Child1 (8ms)
│   └── GrandChild1 (3ms)
└── Child2 (5ms)
```

- **横軸**: コンポーネント階層
- **縦軸**: レンダリング時間
- **色**: 黄色が濃いほど時間がかかっている

### 情報の読み取り

各コンポーネントをクリックすると以下の情報が表示されます:

- **レンダリング時間**: コンポーネントのレンダリングにかかった時間
- **レンダリング回数**: 記録中にレンダリングされた回数
- **Props**: レンダリング時のProps
- **Hooks**: 使用しているHooks
- **レンダリング理由**: なぜ再レンダリングされたか

### ボトルネックの特定

1. **最も黄色い部分を探す**: レンダリング時間が長いコンポーネント
2. **レンダリング回数を確認**: 不要な再レンダリングがないか
3. **子コンポーネントをチェック**: 親のレンダリング時間の内訳を確認

## Rankedビューの使い方

### レンダリング時間順に表示

Rankedビューは、レンダリング時間の長い順にコンポーネントをリスト表示します。

```
1. ExpensiveComponent    (120ms)
2. ListComponent         (85ms)
3. FormComponent         (42ms)
...
```

### 優先順位の決定

1. **最も時間がかかるコンポーネントから最適化**
2. **レンダリング時間が50ms以上のコンポーネントを重点的に**
3. **レンダリング回数も考慮**: 10ms × 20回 = 200ms

## Componentビューの使い方

### 特定コンポーネントの詳細分析

Componentビューでは、選択したコンポーネントの詳細な情報を確認できます:

- **レンダリングタイムライン**: 時系列でのレンダリング
- **Props変更履歴**: Propsがどう変わったか
- **Hooks状態**: 各Hooksの値の変化
- **レンダリング理由**: なぜ再レンダリングされたか

### レンダリング理由の種類

1. **Parent rendered**: 親コンポーネントが再レンダリングされた
2. **Props changed**: Propsが変更された
3. **State changed**: 状態が変更された
4. **Context changed**: Contextの値が変更された
5. **Hooks changed**: Hooksの値が変更された

## 測定設定のカスタマイズ

### 設定オプション

1. **Record why each component rendered**: レンダリング理由を記録（推奨: ON）
2. **Hide commits below threshold**: 指定時間以下のコミットを非表示（推奨: 1ms）
3. **Highlight updates**: レンダリングされたコンポーネントをハイライト

### 推奨設定

```
✅ Record why each component rendered: ON
✅ Hide commits below threshold: 1ms
✅ Highlight updates: ON
```

## 実践的な測定例

### 例1: ボタンクリック時のパフォーマンス測定

**目的**: ボタンクリック時の再レンダリングを最適化

**測定手順**:

1. Profilerで記録開始
2. ボタンを10回クリック
3. 記録停止
4. Flamegraphで以下を確認:
   - どのコンポーネントが再レンダリングされたか
   - レンダリング時間はどのくらいか
   - 不要な再レンダリングはないか

**分析ポイント**:

- ボタンクリックと無関係なコンポーネントが再レンダリングされていないか
- 親コンポーネントの再レンダリングで子が不要に再レンダリングされていないか

### 例2: リスト表示のパフォーマンス測定

**目的**: リスト表示の最適化

**測定手順**:

1. Profilerで記録開始
2. リストに100件のアイテムを表示
3. 1件のアイテムを更新
4. 記録停止
5. Rankedビューで確認:
   - 各ListItemのレンダリング時間
   - 更新されていないアイテムが再レンダリングされていないか

**分析ポイント**:

- すべてのListItemが再レンダリングされていないか
- React.memoで最適化できるか

### 例3: フォーム入力のパフォーマンス測定

**目的**: フォーム入力時の最適化

**測定手順**:

1. Profilerで記録開始
2. テキストフィールドに文字を入力
3. 記録停止
4. Flamegraphで確認:
   - 各キーストロークでどのコンポーネントが再レンダリングされるか
   - レンダリング時間はどのくらいか

**分析ポイント**:

- フォームフィールド以外のコンポーネントが再レンダリングされていないか
- デバウンス処理が必要か

## パフォーマンス指標の読み取り

### レンダリング時間の目安

- **優秀**: 0-10ms
- **良好**: 10-50ms
- **改善推奨**: 50-100ms
- **要改善**: 100ms以上

### レンダリング回数の目安

- **単一操作あたり**: 1-3回
- **改善検討**: 3-10回
- **要改善**: 10回以上

### コミット時間の目安

コミット時間は、ReactがDOMに変更を反映する時間です。

- **優秀**: 0-16ms (60fps)
- **良好**: 16-33ms (30fps)
- **改善推奨**: 33-100ms
- **要改善**: 100ms以上

## トラブルシューティング

### 問題1: Profilerが表示されない

**原因**:
- React DevToolsがインストールされていない
- Reactアプリケーションが検出されていない

**解決策**:
1. React DevToolsを再インストール
2. ページをリロード
3. 開発モードで実行されているか確認

### 問題2: レンダリング理由が表示されない

**原因**:
- 設定で「Record why each component rendered」がOFFになっている

**解決策**:
1. 設定アイコン（⚙️）をクリック
2. 「Record why each component rendered」をON
3. 再度記録

### 問題3: 測定結果が不正確

**原因**:
- 本番ビルドで測定している
- 他の処理が実行されている

**解決策**:
1. 開発モードで測定
2. 他のアプリケーションを閉じる
3. ブラウザのキャッシュをクリア

## 測定データの活用

### 最適化前後の比較

1. **最適化前の測定**:
   - 記録を保存（右クリック → Save profile）
   - レンダリング時間と回数を記録

2. **最適化実施**:
   - React.memo、useCallback、useMemoの適用

3. **最適化後の測定**:
   - 同じ操作を実行して記録
   - 保存した最適化前の記録と比較

### 改善率の計算

```
改善率 = (最適化前の時間 - 最適化後の時間) / 最適化前の時間 × 100%

例:
最適化前: 120ms
最適化後: 40ms
改善率 = (120 - 40) / 120 × 100% = 66.7%
```

### レポート作成

測定結果を基にレポートを作成:

```markdown
## パフォーマンス最適化レポート

### 最適化対象
- コンポーネント: ExpensiveComponent
- 操作: ボタンクリック

### 最適化前
- レンダリング時間: 120ms
- レンダリング回数: 15回
- コミット時間: 8ms

### 最適化内容
- React.memoの適用
- useCallbackでコールバックをメモ化

### 最適化後
- レンダリング時間: 40ms (66.7%削減)
- レンダリング回数: 3回 (80%削減)
- コミット時間: 3ms (62.5%削減)

### 結論
大幅なパフォーマンス改善を達成
```

## ベストプラクティス

### 測定の原則

1. **測定なしに最適化しない**: 必ず測定してからボトルネックを特定
2. **複数回測定**: 1回の測定では正確でない場合がある
3. **実際のユースケース**: 実際のユーザー操作を再現して測定
4. **比較データ**: 最適化前後で必ず比較

### 測定環境

1. **開発モード**: 本番ビルドではなく開発モードで測定
2. **他のアプリ停止**: CPUリソースを確保
3. **キャッシュクリア**: ブラウザのキャッシュをクリアして測定

## チェックリスト

- [ ] React DevTools Profilerをインストール済み
- [ ] 開発モードで実行
- [ ] 「Record why each component rendered」をON
- [ ] 最適化前の測定を実施
- [ ] ボトルネックを特定
- [ ] 最適化を実施
- [ ] 最適化後の測定を実施
- [ ] 改善率を計算
- [ ] レポートを作成
