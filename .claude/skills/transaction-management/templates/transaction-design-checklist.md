# トランザクション設計チェックリスト

## 基本情報

| 項目 | 内容 |
|------|------|
| **日付** | {{YYYY-MM-DD}} |
| **設計者** | {{名前}} |
| **機能名** | {{機能名}} |
| **対象テーブル** | {{テーブル1, テーブル2, ...}} |

---

## 1. トランザクション境界の定義

### 1.1 操作の特定

| 操作 | テーブル | 操作種別 | 順序 |
|------|---------|---------|------|
| {{操作1}} | {{テーブル名}} | INSERT/UPDATE/DELETE | 1 |
| {{操作2}} | {{テーブル名}} | INSERT/UPDATE/DELETE | 2 |

### 1.2 原子性の確認

- [ ] すべての操作が成功するか、すべて失敗するかが適切か
- [ ] 部分的成功が許容される場合、Sagaパターンを検討したか

### 1.3 トランザクション境界

```typescript
// トランザクション範囲
await db.transaction(async (tx) => {
  // 操作1
  // 操作2
  // ...
});
```

---

## 2. 分離レベルの選択

### 2.1 要件分析

| 質問 | 回答 |
|------|------|
| 読み取り専用か？ | ☐ Yes / ☐ No |
| 同一データの複数回読み取りがあるか？ | ☐ Yes / ☐ No |
| 読み取り中にデータが変わると問題か？ | ☐ Yes / ☐ No |
| 複数テーブル間の整合性制約があるか？ | ☐ Yes / ☐ No |
| 競合頻度の予想は？ | ☐ 低 / ☐ 中 / ☐ 高 |

### 2.2 分離レベル決定

- [ ] **READ COMMITTED**: 一般的な操作、競合少ない
- [ ] **REPEATABLE READ**: レポート生成、スナップショット一貫性
- [ ] **SERIALIZABLE**: 金融取引、厳密な整合性

**選択理由**: {{分離レベルを選択した理由}}

---

## 3. ロック戦略

### 3.1 楽観的ロック

- [ ] 楽観的ロックを使用する

**実装方法**:
```typescript
// バージョンカラム
version: integer('version').notNull().default(1)

// 更新時のチェック
.where(and(
  eq(table.id, id),
  eq(table.version, expectedVersion)
))
```

### 3.2 悲観的ロック

- [ ] 悲観的ロックを使用する

**ロックモード**:
- [ ] `FOR UPDATE`: 排他ロック
- [ ] `FOR UPDATE NOWAIT`: 即座にエラー
- [ ] `FOR UPDATE SKIP LOCKED`: ロック行をスキップ

**実装方法**:
```sql
SELECT * FROM {{table}} WHERE id = $1 FOR UPDATE
```

### 3.3 ロック戦略の理由

{{楽観的/悲観的ロックを選択した理由}}

---

## 4. デッドロック回避

### 4.1 リソースアクセス順序

| 順序 | テーブル/リソース |
|------|------------------|
| 1 | {{テーブル1}} |
| 2 | {{テーブル2}} |
| 3 | {{テーブル3}} |

- [ ] 一貫したアクセス順序が定義されているか
- [ ] 複数のIDを操作する場合、ID順にソートしているか

### 4.2 タイムアウト設定

```sql
SET statement_timeout = '{{ミリ秒}}';
SET lock_timeout = '{{ミリ秒}}';
```

---

## 5. 外部リソースの扱い

### 5.1 外部API呼び出し

- [ ] 外部API呼び出しがトランザクション内にある → **要修正**
- [ ] 外部API呼び出しはトランザクション外に分離 → **OK**

### 5.2 補償トランザクション（必要な場合）

| ステップ | 操作 | 補償操作 |
|----------|------|----------|
| 1 | {{操作}} | {{補償}} |
| 2 | {{操作}} | {{補償}} |

---

## 6. エラーハンドリング

### 6.1 リトライ戦略

- [ ] リトライが必要（SERIALIZABLE使用時は必須）
- [ ] リトライ不要

**リトライ設定**:
- 最大リトライ回数: {{N}}回
- 初期待機時間: {{ミリ秒}}ms
- バックオフ: ☐ 固定 / ☐ 指数

### 6.2 リトライ対象エラー

- [ ] シリアライゼーション失敗 (`could not serialize access`)
- [ ] デッドロック検出 (`deadlock detected`)
- [ ] ロックタイムアウト (`lock timeout`)

### 6.3 エラー時の通知

- [ ] ログ出力
- [ ] アラート通知
- [ ] ユーザーへのエラーメッセージ

---

## 7. パフォーマンス考慮

### 7.1 トランザクション時間

- 予想トランザクション時間: {{ミリ秒}}ms
- [ ] 100ms以下 → **OK**
- [ ] 100ms〜1000ms → 最適化検討
- [ ] 1000ms以上 → **要最適化**

### 7.2 最適化ポイント

- [ ] 不要な読み取りを削除
- [ ] バッチ処理で一括操作
- [ ] インデックス活用
- [ ] 外部呼び出しの分離

---

## 8. テスト計画

### 8.1 正常系テスト

| テストケース | 期待結果 |
|-------------|----------|
| 単一トランザクション成功 | すべての操作が反映 |
| 複数操作の原子性 | 全成功または全ロールバック |

### 8.2 異常系テスト

| テストケース | 期待結果 |
|-------------|----------|
| 途中でエラー発生 | ロールバック |
| 同時実行（競合） | 適切な分離 |
| デッドロック発生 | リトライまたはエラー |

### 8.3 負荷テスト

- [ ] 同時トランザクション数: {{N}}
- [ ] 期待スループット: {{TPS}}

---

## 9. 実装コード

```typescript
// トランザクション実装
async function {{functionName}}({{params}}): Promise<{{returnType}}> {
  return await withRetry(async () => {
    return await db.transaction(async (tx) => {
      // 操作1
      // 操作2
      // ...
    }, { isolationLevel: '{{isolationLevel}}' });
  }, {{maxRetries}});
}
```

---

## 10. 承認

| 役割 | 名前 | 承認日 |
|------|------|--------|
| 設計者 | {{名前}} | {{日付}} |
| レビュアー | {{名前}} | {{日付}} |
| DBA | {{名前}} | {{日付}} |
