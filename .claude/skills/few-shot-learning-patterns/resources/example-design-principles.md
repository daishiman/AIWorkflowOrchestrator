# 例示設計の原則

## 概要

効果的なFew-Shot Learningの核心は、
質の高い例示の設計にあります。

## 5つの設計原則

### 1. 代表性（Representativeness）

**定義**: 例示がタスクの典型的なケースを代表すること

**良い例**:
```markdown
タスク: メールを「業務」「私用」に分類

例1（業務の典型）:
入力: 「明日の会議資料を添付します。ご確認ください。」
出力: 業務

例2（私用の典型）:
入力: 「週末の飲み会、参加できる？」
出力: 私用
```

**悪い例**:
```markdown
# 極端なケースばかり
例1: 「CEO宛の機密報告書を至急送付」  # 極端に業務的
例2: 「愛してる」  # 極端に私用的
```

**チェックリスト**:
- [ ] 実際のユースケースの80%をカバーしているか
- [ ] 日常的なケースを含んでいるか
- [ ] 現実的なデータを使用しているか

### 2. 多様性（Diversity）

**定義**: 異なるバリエーションを網羅すること

**多様性の軸**:
1. **長さ**: 短い入力と長い入力
2. **複雑さ**: 単純なケースと複雑なケース
3. **パターン**: 異なる入力形式
4. **エッジケース**: 境界的な状況

**実装例**:
```markdown
タスク: テキストから感情を抽出

例1（短い、単純）:
入力: 「嬉しい！」
出力: { "emotion": "joy", "intensity": "high" }

例2（長い、複雑）:
入力: 「今日の発表はうまくいったと思うけど、
まだ不安な部分もある。でも全体的には満足。」
出力: { "emotion": "mixed", "primary": "satisfaction",
        "secondary": "anxiety", "intensity": "medium" }

例3（曖昧、エッジ）:
入力: 「ふーん、そうなんだ」
出力: { "emotion": "neutral", "intensity": "low" }
```

### 3. 一貫性（Consistency）

**定義**: すべての例示で同じルールを適用すること

**一貫性が必要な要素**:
| 要素 | 一貫すべき点 |
|------|-------------|
| フォーマット | 入出力の構造 |
| 命名 | ラベル、キー名 |
| 処理 | 同じ入力への同じ処理 |
| スタイル | 文体、記法 |

**悪い例（不一貫）**:
```markdown
例1:
入力: 100円
出力: ¥100

例2:
入力: 200円
出力: 200 yen  # 形式が違う！

例3:
入力: 300円
出力: 三百円  # さらに違う形式！
```

**良い例（一貫）**:
```markdown
例1:
入力: 100円
出力: ¥100

例2:
入力: 200円
出力: ¥200

例3:
入力: 1000円
出力: ¥1,000
```

### 4. 漸進的複雑性（Progressive Complexity）

**定義**: 簡単な例から複雑な例へ順序付けること

**推奨順序**:
```
例1: 最もシンプル → 基本パターンを学習
例2: 標準的 → 一般的なケースを学習
例3: やや複雑 → バリエーションを学習
例4: 複雑/エッジ → 例外処理を学習
```

**実装例**:
```markdown
タスク: 日付を正規化

例1（シンプル）:
入力: 2024年1月1日
出力: 2024-01-01

例2（標準）:
入力: 2024/1/15
出力: 2024-01-15

例3（やや複雑）:
入力: 令和6年3月20日
出力: 2024-03-20

例4（複雑）:
入力: 来月の第2火曜日
出力: [相対日付のため変換不可]
```

### 5. 明示性（Explicitness）

**定義**: 暗黙のルールを可視化すること

**暗黙のルールの例**:
- 空白の扱い方
- 大文字小文字の処理
- エラー時の出力
- デフォルト値

**暗黙→明示の変換**:
```markdown
# 暗黙的（悪い）
例1: "Hello World" → "hello world"
例2: "Good Morning" → "good morning"
# ルール（大文字→小文字）が暗黙

# 明示的（良い）
ルール: すべての文字を小文字に変換します

例1:
入力: "Hello World"
出力: "hello world"

例2:
入力: "Good Morning"
出力: "good morning"
```

## 例示の品質評価

### 評価マトリックス

| 基準 | 低品質 | 中品質 | 高品質 |
|------|-------|-------|-------|
| 代表性 | 極端なケースのみ | 一部典型的 | 主要ケースを網羅 |
| 多様性 | 同パターンの反復 | 一部バリエーション | 多軸での多様性 |
| 一貫性 | ルールが矛盾 | ほぼ一貫 | 完全に一貫 |
| 複雑性 | ランダム順 | 部分的に順序化 | 漸進的に配置 |
| 明示性 | すべて暗黙 | 一部明示 | 主要ルール明示 |

### スコアリング例

```yaml
example_set_evaluation:
  task: "感情分類"
  examples_count: 4

  scores:
    representativeness: 4/5  # 主要感情をカバー
    diversity: 3/5           # 長さの多様性が不足
    consistency: 5/5         # 形式が完全に一貫
    progressive_complexity: 4/5  # おおむね順序化
    explicitness: 3/5        # 一部ルールが暗黙

  overall: 3.8/5
  recommendation: "多様性と明示性の改善が必要"
```

## よくある設計ミス

### ミス1: 過度な単純化

```markdown
# 悪い例
例1: "A" → "a"
例2: "B" → "b"

# 良い例
例1: "Hello World" → "hello world"
例2: "IMPORTANT: Meeting Today" → "important: meeting today"
```

### ミス2: 説明の過多

```markdown
# 悪い例（冗長）
例1:
入力テキスト（これは分類対象のテキストです）: "素晴らしい製品です"
出力ラベル（ポジティブ/ネガティブ/中立のいずれか）: ポジティブ
理由（なぜこの分類になったか）: 「素晴らしい」は肯定的な表現

# 良い例（簡潔）
例1:
入力: "素晴らしい製品です"
出力: ポジティブ
```

### ミス3: 不自然なデータ

```markdown
# 悪い例（人工的）
例1: "XXX製品YYYは価格ZZZ円です"
例2: "AAA機能はBBB性能でCCCが特徴"

# 良い例（自然）
例1: "iPhone 15 Proは159,800円です"
例2: "A15チップは高性能で省電力が特徴"
```

## 設計プロセス

### Step 1: タスク分解

```
タスク: [タスク名]
├─ 入力の種類: [A, B, C, ...]
├─ 出力の形式: [フォーマット]
├─ 暗黙のルール: [ルール1, ルール2, ...]
└─ エッジケース: [ケース1, ケース2, ...]
```

### Step 2: 例示候補の収集

```
収集源:
├─ 実際のデータサンプル
├─ ユーザーの期待出力例
├─ エラーケースのログ
└─ ドメイン専門家の知見
```

### Step 3: 選択と順序化

```
選択基準:
├─ 代表性スコア
├─ 多様性への貢献
├─ 複雑性レベル
└─ 明示すべきルール
```

### Step 4: 検証と改善

```
検証方法:
├─ 実際の入力でテスト
├─ 一貫性の確認
├─ エッジケースの検証
└─ フィードバックの収集
```
