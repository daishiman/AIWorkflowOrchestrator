# エージェントアーキテクチャパターンカタログ

## パターン1: オーケストレーター・ワーカー

### 概要
中央のオーケストレーターが複数のワーカーエージェントを統括し、タスクを分配・管理するパターン。

### 構造
```
オーケストレーター（統括）
  ├─ ワーカー1（専門タスクA）
  ├─ ワーカー2（専門タスクB）
  └─ ワーカー3（専門タスクC）
```

### 適用条件
- 複数のサブタスクが並列実行可能
- 全体の進捗管理が重要
- タスク間の依存関係が少ない
- 中央集権的な制御が必要

### 利点
- 全体制御が容易
- 並列化が自然に実現
- ワーカーの追加・削除が容易
- 進捗の可視化が簡単

### 欠点
- オーケストレーターがボトルネックになりやすい
- オーケストレーターの実装が複雑化しやすい
- 単一障害点（SPOF）のリスク

### 実装例
```yaml
orchestrator:
  name: project-orchestrator
  tools:
  - Task
  - Read
  workflow:
    - タスク分析と分割
    - ワーカーへの委譲
    - 進捗監視
    - 結果統合

workers:
  - name: code-generator
    tools:
      - Read
      - Write
      - Edit
  - name: test-runner
    tools:
  - Bash
  - Read
  - name: documenter
    tools:
      - Read
      - Write
```

### アンチパターン
- ❌ オーケストレーターがすべての詳細を把握
- ❌ ワーカー間の直接通信
- ❌ オーケストレーターが実装も担当

---

## パターン2: ハブアンドスポーク

### 概要
中央のハブが共通データを管理し、複数のスポーク（エージェント）がハブを介してデータにアクセスするパターン。

### 構造
```
      ハブ（データ管理）
       ↑↓
  ┌────┼────┐
スポーク1  スポーク2  スポーク3
```

### 適用条件
- 複数のエージェントが共通リソースにアクセス
- データの一元管理が必要
- エージェント間の直接通信を避けたい
- データ整合性が重要

### 利点
- データ整合性が保たれる
- エージェント間の疎結合
- スポークの追加が容易
- データアクセスの統一的管理

### 欠点
- ハブが単一障害点
- ハブの実装が複雑化
- データアクセスのオーバーヘッド

### 実装例
```yaml
hub:
  name: data-hub
  tools:
  - Read
  - Write
  responsibilities:
    - 共通データの管理
    - アクセス制御
    - データ検証

spokes:
  - name: data-analyzer
  - name: data-transformer
  - name: data-validator
```

---

## パターン3: パイプライン

### 概要
データが段階的に変換されながらエージェント間を流れるパターン。

### 構造
```
入力 → エージェント1 → エージェント2 → エージェント3 → 出力
```

### 適用条件
- データが段階的に変換される
- 各ステップが独立している
- ストリーム処理が有効
- 処理の順序が固定

### 利点
- 各ステージが独立
- テストが容易
- 責務が明確
- スケーリングが容易

### 欠点
- 柔軟性が低い
- エラーの伝播
- 処理順序の変更が困難

### 実装例
```yaml
pipeline:
  stages:
    - name: data-extraction
      input: raw_data
      output: structured_data
    - name: data-validation
      input: structured_data
      output: validated_data
    - name: data-transformation
      input: validated_data
      output: final_data
```

---

## パターン4: ステートマシン

### 概要
明確な状態遷移に基づいてエージェントが動作するパターン。

### 構造
```
状態A ─(条件1)→ 状態B ─(条件2)→ 状態C
  ↑                              ↓
  └──────(エラー時)──────────────┘
```

### 適用条件
- 明確な状態遷移がある
- 条件分岐が複雑
- エラーからのリカバリーが重要
- ワークフローが動的に変化

### 利点
- 状態が明確
- エラー処理が容易
- デバッグが容易
- 状態の可視化が簡単

### 欠点
- 複雑な遷移は管理困難
- 状態数の増加で複雑化
- オーバーエンジニアリングのリスク

### 実装例
```yaml
state_machine:
  initial_state: analyzing
  states:
    analyzing:
      on_success: implementing
      on_error: error_handling
    implementing:
      on_success: testing
      on_error: error_handling
    testing:
      on_success: completed
      on_error: implementing
    error_handling:
      on_resolved: analyzing
      on_failure: failed
```

---

## パターン選択ガイド

### 質問ベースの選択

**Q1: タスクの主要な特性は？**
- 並列処理が主 → オーケストレーター・ワーカー
- データ共有が主 → ハブアンドスポーク
- 段階的変換が主 → パイプライン
- 状態遷移が主 → ステートマシン

**Q2: スケーラビリティの要件は？**
- 高い → パイプライン、オーケストレーター・ワーカー
- 中程度 → ハブアンドスポーク
- 低い → ステートマシン

**Q3: エラーハンドリングの複雑度は？**
- 高い → ステートマシン
- 中程度 → オーケストレーター・ワーカー、ハブアンドスポーク
- 低い → パイプライン

---

## ハイブリッドパターン

複数のパターンを組み合わせることも可能:

### 例: オーケストレーター + パイプライン
```
オーケストレーター
  ├─ パイプライン1（データ処理）
  ├─ パイプライン2（テスト実行）
  └─ ワーカー（ドキュメント生成）
```

### 例: ハブ + ステートマシン
```
ハブ（状態管理）
  ↑↓
ステートマシン（ワークフロー制御）
```

---

## まとめ

| パターン | 主な用途 | 複雑度 | スケーラビリティ |
|---------|---------|--------|----------------|
| オーケストレーター・ワーカー | 並列タスク | 中 | 高 |
| ハブアンドスポーク | データ共有 | 中 | 中 |
| パイプライン | データ変換 | 低 | 高 |
| ステートマシン | 状態遷移 | 高 | 低 |
