# CoTプロンプティング技法

## 概要

Chain-of-Thoughtを効果的に引き出すための
具体的なプロンプティング技法を解説します。

## Zero-Shot CoT技法

### 基本トリガーフレーズ

**英語版**:
| フレーズ | 効果 | 最適用途 |
|---------|------|---------|
| "Let's think step by step." | 標準的 | 汎用 |
| "Let's work through this problem." | 問題解決指向 | 複雑な問題 |
| "Let's break this down." | 分解指向 | 構造化タスク |
| "First, let's understand what we know." | 情報整理 | 分析タスク |
| "Let me reason through this carefully." | 慎重な推論 | 高精度要求 |

**日本語版**:
| フレーズ | 効果 | 最適用途 |
|---------|------|---------|
| "段階的に考えてみましょう。" | 標準的 | 汎用 |
| "順を追って解いていきましょう。" | 順序重視 | 計算問題 |
| "まず、与えられた情報を整理します。" | 情報整理 | 分析タスク |
| "一つずつ確認していきましょう。" | 確認重視 | 検証タスク |
| "論理的に分析してみましょう。" | 論理重視 | 推論タスク |

### トリガーの配置

**パターン1: 末尾配置（標準）**
```markdown
問題: [問題文]

Let's think step by step.
```

**パターン2: 中間配置**
```markdown
問題: [問題文]

Let's think step by step.

最終的な答えを出してください。
```

**パターン3: 複合トリガー**
```markdown
問題: [問題文]

まず、与えられた情報を整理します。
そして、段階的に解いていきましょう。
最後に、答えを検証します。
```

## Few-Shot CoT技法

### 例示の構造化

**基本形式**:
```markdown
例1:
Q: [質問]
A: [思考プロセス]
   [最終回答]

例2:
Q: [質問]
A: [思考プロセス]
   [最終回答]
```

**詳細形式**:
```markdown
例1:
問題: [問題文]

分析:
1. [ステップ1の説明]
2. [ステップ2の説明]
3. [ステップ3の説明]

計算:
- [計算1]
- [計算2]

検証:
- [検証内容]

答え: [最終回答]
```

### 例示数の最適化

```yaml
recommended_examples:
  simple_reasoning: 1-2  # シンプルな推論
  moderate_complexity: 2-3  # 中程度の複雑さ
  complex_reasoning: 3-5  # 複雑な推論
  high_precision: 4-6  # 高精度要求
```

### 多様性の確保

```markdown
# 良い例示セット（多様性あり）

例1（短い推論）:
問題: 3 × 4 = ?
思考: 3を4回足す → 3 + 3 + 3 + 3 = 12
答え: 12

例2（中程度の推論）:
問題: 15% の 80 は？
思考:
1. 15% = 0.15
2. 0.15 × 80 = 12
答え: 12

例3（長い推論）:
問題: 商品が20%引きで800円。元の価格は？
思考:
1. 20%引き = 80%の価格
2. 800円 = 元の価格 × 0.8
3. 元の価格 = 800 ÷ 0.8 = 1000
答え: 1000円
```

## 構造化プロンプト

### セクション分割

```markdown
# タスク
[タスクの説明]

# 制約
- [制約1]
- [制約2]

# 思考プロセス
以下の形式で回答してください：

## 1. 情報整理
[与えられた情報を整理]

## 2. 分析
[問題の分析]

## 3. 推論
[段階的な推論]

## 4. 結論
[最終的な回答]

# 入力
[実際の問題]
```

### 役割設定との組み合わせ

```markdown
あなたは論理的思考の専門家です。
問題を解く際は、以下のプロセスに従ってください：

1. 問題の理解
2. アプローチの選択
3. 段階的な解決
4. 検証

では、以下の問題を解いてください：

[問題文]

思考プロセス:
```

## 推論構造の指定

### 明示的な構造指定

```markdown
以下の問題を解いてください。

問題: [問題文]

回答は以下の形式で記述してください：

【前提の確認】
- ...

【推論ステップ】
ステップ1: ...
ステップ2: ...
ステップ3: ...

【結論】
...

【検算/検証】
...
```

### 推論タイプの指定

```markdown
演繹的推論を使用して、以下の問題を解いてください。

前提:
1. すべてのAはBである
2. CはAである

問題: Cについて何が言えますか？

推論:
```

## Self-Consistency技法

### 基本実装

```markdown
以下の問題を3つの異なるアプローチで解いてください。

問題: [問題文]

アプローチ1:
[推論1]
答え1: [回答]

アプローチ2:
[推論2]
答え2: [回答]

アプローチ3:
[推論3]
答え3: [回答]

最終回答:
3つの回答を比較し、最も信頼できる回答を選択してください。
```

### プログラム的実装

```typescript
async function selfConsistencyCoT(
  prompt: string,
  numSamples: number = 5,
  temperature: number = 0.7
): Promise<string> {
  const responses = await Promise.all(
    Array(numSamples).fill(null).map(() =>
      generateWithCoT(prompt, { temperature })
    )
  );

  // 回答を抽出
  const answers = responses.map(r => extractAnswer(r));

  // 多数決
  const counts = countOccurrences(answers);
  return getMostFrequent(counts);
}
```

## 検証ステップの組み込み

### 自己検証プロンプト

```markdown
問題を解き、その後で回答を検証してください。

問題: [問題文]

解答プロセス:
1. [ステップ1]
2. [ステップ2]
3. [ステップ3]

暫定回答: [回答]

検証:
- 計算は正しいか？ [はい/いいえ]
- 論理は一貫しているか？ [はい/いいえ]
- 別のアプローチでも同じ結果になるか？ [検証]

最終回答: [修正があれば修正した回答]
```

### デバッグ形式

```markdown
以下の問題を解いてください。各ステップで
「ここまで正しいか？」を確認してください。

問題: [問題文]

ステップ1: [処理]
✓ チェック: [確認内容]

ステップ2: [処理]
✓ チェック: [確認内容]

ステップ3: [処理]
✓ チェック: [確認内容]

最終回答: [回答]
最終チェック: [全体の整合性確認]
```

## 言語モデル固有の調整

### Claude向け

```markdown
# Claudeでの効果的なCoT

1. XMLタグを使用した構造化
<thinking>
[推論プロセス]
</thinking>

<answer>
[最終回答]
</answer>

2. 明確な指示
「段階的に考え、各ステップを明示してください」
```

### GPT向け

```markdown
# GPTでの効果的なCoT

1. システムメッセージでの設定
System: "You are a helpful assistant that thinks step by step."

2. フォーマット指示
"Format your response as:
Thinking: [your reasoning]
Answer: [final answer]"
```

## エラー処理

### 推論の行き詰まり対策

```markdown
問題を解いてください。
もし行き詰まった場合は、以下を試してください：
1. 問題を言い換える
2. 小さなサブ問題に分解する
3. 類似問題との比較
4. 仮定を明示する

問題: [問題文]

思考プロセス:
[行き詰まったら上記のテクニックを使用]
```

### 不確実性の表明

```markdown
問題を解き、確信度も示してください。

問題: [問題文]

推論:
[段階的推論]

回答: [回答]
確信度: [高/中/低]
不確実な点: [あれば記載]
```
