# 推論パターン集

## 概要

様々な問題タイプに適した推論パターンを紹介します。
タスクに応じて適切なパターンを選択してください。

## 演繹推論パターン

### 基本形式

```
前提1: AならばB
前提2: Aである
結論: したがって、Bである
```

### プロンプト例

```markdown
以下の情報から論理的に結論を導いてください。

前提:
1. すべての哺乳類は温血動物である
2. クジラは哺乳類である

演繹推論:
1. 前提1より: 哺乳類 → 温血動物
2. 前提2より: クジラ → 哺乳類
3. 推移律より: クジラ → 哺乳類 → 温血動物

結論: クジラは温血動物である
```

### 適用場面

- 数学の証明
- 論理パズル
- ルールベースの判断
- 法的推論

## 帰納推論パターン

### 基本形式

```
観察1: X₁はYである
観察2: X₂はYである
観察3: X₃はYである
一般化: すべてのXはYである（推測）
```

### プロンプト例

```markdown
以下のデータからパターンを見つけてください。

データ:
- 2024年1月: 売上120万円、気温5°C
- 2024年2月: 売上110万円、気温8°C
- 2024年7月: 売上180万円、気温30°C
- 2024年8月: 売上195万円、気温32°C

帰納推論:
1. 冬季（1-2月）: 売上110-120万円、気温5-8°C
2. 夏季（7-8月）: 売上180-195万円、気温30-32°C
3. パターン: 気温が高い月は売上が高い傾向

仮説: 気温と売上に正の相関がある可能性
確信度: 中（データポイントが4つのみ）
検証方法: 他の月のデータで確認が必要
```

### 適用場面

- データ分析
- 傾向予測
- パターン認識
- 仮説生成

## 類推推論パターン

### 基本形式

```
既知: AはBに対してXの関係にある
観察: CはAに類似している
推論: CはDに対してXの関係にあるかもしれない
```

### プロンプト例

```markdown
類推を使って問題を解いてください。

既知のケース:
問題: チームのモチベーションが低下
解決: 定期的な1on1ミーティングを導入
結果: コミュニケーションが改善し、モチベーション回復

新しいケース:
問題: リモートワークでチームの一体感が薄れている

類推推論:
1. 両ケースの類似点:
   - チームの結束に関する問題
   - コミュニケーション不足が根本原因

2. 解決策の転用:
   - 定期的なオンライン1on1を導入
   - 加えて、週次のバーチャルチーム会議

3. 期待される効果:
   - コミュニケーション頻度の増加
   - 一体感の回復

注意: 完全な類推ではない点
- リモートワーク固有の課題（時差、ツール）
```

### 適用場面

- 問題解決
- 知識の転移
- 創造的発想
- 説明・教育

## 仮説検証パターン

### 基本形式

```
観察: 現象Xが発生している
仮説1: 原因はAである
仮説2: 原因はBである
検証: 各仮説をテスト
結論: 最も整合する仮説を採用
```

### プロンプト例

```markdown
以下の問題の原因を仮説検証で特定してください。

症状: Webアプリケーションが時々遅くなる

仮説の列挙:
1. データベースクエリが遅い
2. メモリリークが発生している
3. 外部APIの応答が遅い
4. サーバーの負荷が高い

検証:
仮説1（DB）:
- クエリログを確認 → 一部のクエリが3秒以上
- スロークエリが遅延タイミングと一致 ✓

仮説2（メモリ）:
- メモリ使用量は安定 ✗

仮説3（外部API）:
- 外部APIのレスポンスタイムは正常 ✗

仮説4（負荷）:
- CPU使用率は30%で安定 ✗

結論: データベースのスロークエリが主原因
推奨: クエリの最適化、インデックスの追加
```

### 適用場面

- デバッグ
- 根本原因分析
- 科学的調査
- トラブルシューティング

## 分割統治パターン

### 基本形式

```
大きな問題
├─ サブ問題1 → 解1
├─ サブ問題2 → 解2
└─ サブ問題3 → 解3
            ↓
解1 + 解2 + 解3 → 全体の解
```

### プロンプト例

```markdown
複雑な問題を分割して解いてください。

問題: 新しいECサイトの設計

分割:
1. フロントエンド設計
2. バックエンド設計
3. データベース設計
4. インフラ設計

サブ問題の解決:

1. フロントエンド設計:
   - フレームワーク: Next.js
   - 状態管理: Redux Toolkit
   - スタイリング: Tailwind CSS

2. バックエンド設計:
   - API: GraphQL
   - 認証: OAuth2.0
   - 言語: Node.js

3. データベース設計:
   - メイン: PostgreSQL
   - キャッシュ: Redis
   - 検索: Elasticsearch

4. インフラ設計:
   - クラウド: AWS
   - コンテナ: ECS
   - CDN: CloudFront

統合:
全体アーキテクチャ図と各コンポーネントの接続点を定義
```

### 適用場面

- システム設計
- プロジェクト計画
- 複雑な計算
- 大規模な分析

## 逆問題パターン

### 基本形式

```
目標: 結果Yを達成したい
逆算: Yを達成するには何が必要か？
      → Xが必要
      → Xを達成するには？
      → ...
```

### プロンプト例

```markdown
逆算して計画を立ててください。

目標: 6ヶ月後に新製品をローンチする

逆算:
ローンチ（6ヶ月後）
├─ 必要: 製品完成、マーケティング準備
│
5ヶ月後
├─ 必要: ベータテスト完了、バグ修正
│
4ヶ月後
├─ 必要: MVP完成、テスト開始
│
3ヶ月後
├─ 必要: 主要機能実装完了
│
2ヶ月後
├─ 必要: 設計完了、開発開始
│
1ヶ月後
├─ 必要: 要件定義、設計

計画:
Month 1: 要件定義・設計
Month 2: 開発開始・基盤構築
Month 3: 主要機能実装
Month 4: MVP完成・テスト開始
Month 5: ベータテスト・改善
Month 6: 最終調整・ローンチ
```

### 適用場面

- プロジェクト計画
- 目標設定
- 問題解決
- 戦略立案

## 比較分析パターン

### 基本形式

```
選択肢A vs 選択肢B
├─ 基準1: A=X, B=Y
├─ 基準2: A=X, B=Y
├─ 基準3: A=X, B=Y
└─ 総合評価 → 推奨選択
```

### プロンプト例

```markdown
以下の選択肢を比較分析してください。

選択肢:
A. React Native（クロスプラットフォーム）
B. Swift + Kotlin（ネイティブ）

分析基準と評価:

| 基準 | React Native | Native | 重要度 |
|------|-------------|--------|--------|
| 開発速度 | ◎ 速い | △ 遅い | 高 |
| パフォーマンス | ○ 良好 | ◎ 最高 | 中 |
| 保守性 | ◎ 単一コードベース | △ 2つのコードベース | 高 |
| ネイティブ機能 | ○ ブリッジ経由 | ◎ 直接アクセス | 中 |
| 人材確保 | ◎ JS開発者多い | ○ 専門性必要 | 高 |
| 長期コスト | ◎ 低い | △ 高い | 高 |

総合評価:
- React Native: 高重要度項目で優位（開発速度、保守性、人材、コスト）
- Native: 中重要度項目で優位（パフォーマンス、ネイティブ機能）

推奨: React Native
理由: ビジネス要件（速度、コスト）を優先する場合に適切
例外: 高度なネイティブ機能が必須の場合はNative推奨
```

### 適用場面

- 意思決定支援
- 技術選定
- 製品比較
- 投資判断

## パターン選択ガイド

```yaml
pattern_selection:
  論理的証明が必要:
    primary: 演繹推論
    secondary: 仮説検証

  データからパターンを見つける:
    primary: 帰納推論
    secondary: 比較分析

  既存知識を新状況に適用:
    primary: 類推推論

  問題の原因を特定:
    primary: 仮説検証
    secondary: 分割統治

  複雑な問題を解く:
    primary: 分割統治
    secondary: 逆問題

  計画を立てる:
    primary: 逆問題
    secondary: 分割統治

  選択肢を評価:
    primary: 比較分析
```
