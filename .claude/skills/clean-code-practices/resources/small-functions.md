# 小さな関数の原則

## 概要

関数は小さくあるべきです。小さな関数は読みやすく、理解しやすく、テストしやすいです。

## サイズのガイドライン

### 理想的なサイズ

- **行数**: 5-10行
- **上限**: 20-30行
- **ネストの深さ**: 最大2段階
- **パラメータ数**: 最大3つ

### なぜ小さくすべきか

1. **理解しやすい**: 一目で全体を把握できる
2. **テストしやすい**: テストケースが少なくて済む
3. **再利用しやすい**: 単一目的なので再利用が容易
4. **変更しやすい**: 影響範囲が限定的

## 単一責任原則

### 一つのことだけを行う

関数は「一つのこと」だけを行い、それを上手くやるべきです。

**判断基準**:

- 関数名が処理内容を正確に表現しているか？
- 関数を意味のある名前で分割できないか？
- 関数に複数の「段落」がないか？

### 抽象度の統一

関数内のすべてのステートメントは、同じ抽象度レベルにあるべきです。

**レベルの例**:

- 高レベル: `processOrder()`, `validateUser()`
- 中レベル: `calculateTotal()`, `formatAddress()`
- 低レベル: `str.trim()`, `array.push()`

## 関数の抽出タイミング

### 抽出すべきサイン

- コメントで説明しているコードブロック
- 条件式の then/else ブロック
- ループの中身
- 計算ロジック

### 抽出のプロセス

1. 独立した意味を持つコードブロックを特定
2. 適切な名前を考える
3. 必要なパラメータを決定
4. 新しい関数を作成
5. 元のコードを関数呼び出しに置換

## パラメータ数

### 推奨される数

- **0個（niladic）**: 最も良い
- **1個（monadic）**: 良い
- **2個（dyadic）**: 許容可能
- **3個（triadic）**: 慎重に

### 多すぎる場合の対処

1. **パラメータオブジェクトを導入**: 関連するパラメータをオブジェクトに
2. **関数を分割**: 責任を分離
3. **メソッドに変換**: オブジェクトのメソッドとして実装

## 副作用を避ける

### 副作用とは

関数が期待される処理以外のことを行うこと。

**例**:

- グローバル変数の変更
- 引数の変更
- I/O操作（明示的でない場合）

### 純粋関数を目指す

同じ入力に対して常に同じ出力を返す関数。

**利点**:

- テストが容易
- 予測可能
- 並列処理が安全

## チェックリスト

### 関数作成時

- [ ] 関数は20行以下か？
- [ ] 一つのことだけを行っているか？
- [ ] 抽象度が統一されているか？
- [ ] パラメータは3つ以下か？

### リファクタリング時

- [ ] コメントで説明しているブロックはないか？
- [ ] 条件式のブロックは抽出できないか？
- [ ] ループの中身は抽出できないか？
- [ ] 副作用を分離できないか？

## アンチパターン

### スパゲッティ関数

制御フローが複雑で追いにくい関数。

**対処**: 制御フローを整理、ガード節を使用

### 神関数

何でもやる巨大な関数。

**対処**: 単一責任に分割

### フラグ引数

ブール値のフラグでロジックを分岐させる。

**対処**: 別々の関数に分割
