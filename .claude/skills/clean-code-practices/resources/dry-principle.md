# DRY原則（Don't Repeat Yourself）

## 概要

DRY原則は「すべての知識は、システム内で単一の、曖昧さのない、信頼できる表現を持つべき」
という原則です。コードの重複を排除することで、保守性と一貫性を向上させます。

## DRYが重要な理由

### 変更の容易さ

重複がなければ、変更は一箇所で済みます。

### 一貫性の維持

同じロジックが一箇所にあれば、一貫性が保証されます。

### バグの減少

重複箇所での修正漏れがなくなります。

## 重複の種類

### 1. コードの重複

同じコードが複数箇所に存在。

**検出方法**:

- コピー&ペーストしたコード
- 類似したコードブロック
- 同じパターンの繰り返し

### 2. 知識の重複

同じ情報が複数の形式で存在。

**例**:

- 定数と文字列リテラル
- スキーマと検証ロジック
- ドキュメントとコード

### 3. 構造の重複

同じパターンが繰り返される。

**例**:

- 類似した条件分岐
- 同じ形式のCRUD操作
- 繰り返しのエラーハンドリング

## DRYの適用

### 関数への抽出

重複するロジックを関数に抽出。

**適用条件**:

- 3回以上の重複（Rule of Three）
- 概念的に同じ処理
- 変更時に複数箇所を修正する必要がある

### 定数の定義

マジックナンバーや文字列を定数化。

**適用条件**:

- 同じ値が複数箇所で使用
- 値に意味がある
- 将来変更される可能性がある

### 抽象化

共通パターンを抽象化。

**適用条件**:

- 構造的な類似性がある
- 変化する部分と固定部分が明確
- 抽象化によって理解しやすくなる

## DRYの落とし穴

### 1. 早すぎる抽象化

**問題**: 類似していると思い込んで抽象化するが、実際は異なる概念。

**対処**:

- 最低3回の重複を待つ
- 本当に同じ知識かを確認
- 必要になるまで抽象化を遅らせる

### 2. 偶然の類似

**問題**: 見た目は同じだが、概念的に異なるものを共通化。

**対処**:

- 「なぜ同じか」を問う
- 将来の変更方向を考える
- 別々に進化する可能性を評価

### 3. 過度な共通化

**問題**: 無理に共通化して複雑になる。

**対処**:

- 共通化のコストを評価
- 読みやすさを優先
- 適度な重複を許容

## WET（Write Everything Twice）のケース

意図的な重複が許容される場合：

### テストコード

テストの独立性と明確さのため。

### 異なるコンテキスト

将来異なる方向に進化する可能性がある場合。

### 複雑さの回避

共通化により複雑になる場合。

## チェックリスト

### 重複発見時

- [ ] 3回以上の重複か？
- [ ] 概念的に同じ知識か？
- [ ] 一緒に変更される可能性が高いか？
- [ ] 共通化のコストは妥当か？

### 抽象化実施時

- [ ] 抽象化で理解しやすくなるか？
- [ ] 適切な名前を付けられるか？
- [ ] テストは通るか？
