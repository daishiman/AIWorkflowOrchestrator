# 非正規化決定記録テンプレート

## 基本情報

| 項目                   | 内容              |
| ---------------------- | ----------------- |
| **日付**               | {{YYYY-MM-DD}}    |
| **決定者**             | {{担当者名}}      |
| **対象テーブル**       | {{テーブル名}}    |
| **対象カラム**         | {{カラム名}}      |
| **現在の正規化レベル** | {{3NF / BCNF 等}} |
| **非正規化後のレベル** | {{2NF / 1NF 等}}  |

---

## 非正規化の種類

以下から該当するものを選択:

- [ ] **計算済みカラム**: 事前計算した値の保存
- [ ] **冗長な参照データ**: 参照テーブルのデータ複製
- [ ] **集約テーブル**: 事前集計したサマリーデータ
- [ ] **履歴スナップショット**: 変更前の値の保存
- [ ] **非正規化された関係**: JOINを避けるための統合

---

## 背景と理由

### 現状の問題

```markdown
{{現在のパフォーマンス問題や要件を記述}}

例:

- 注文一覧ページで毎回 subtotal + tax の計算が必要
- 1日あたり約15,000回の読み取りリクエスト
- 平均応答時間: 180ms
- 目標応答時間: 100ms以下
```

### 測定データ

| メトリクス              | 現在値   | 目標値   |
| ----------------------- | -------- | -------- |
| 平均応答時間            | {{値}}ms | {{値}}ms |
| P99応答時間             | {{値}}ms | {{値}}ms |
| 1日あたりのリクエスト数 | {{値}}   | -        |
| CPU使用率               | {{値}}%  | -        |

### 非正規化による期待効果

```markdown
{{非正規化で得られる改善を記述}}

例:

- JOIN回数の削減: 3 → 1
- 計算の削減: 毎リクエスト → 更新時のみ
- 予想される応答時間改善: 180ms → 80ms
```

---

## トレードオフ分析

### メリット

- [ ] 読み取りパフォーマンス向上
- [ ] クエリの簡素化
- [ ] CPU使用率の削減
- [ ] その他: {{記述}}

### デメリット

- [ ] 更新時の追加処理が必要
- [ ] データ整合性リスク
- [ ] ストレージ使用量の増加
- [ ] スキーマ変更の複雑化
- [ ] その他: {{記述}}

### リスク評価

| リスク                 | 発生確率     | 影響度       | 軽減策   |
| ---------------------- | ------------ | ------------ | -------- |
| データ不整合           | {{低/中/高}} | {{低/中/高}} | {{対策}} |
| 更新パフォーマンス劣化 | {{低/中/高}} | {{低/中/高}} | {{対策}} |
| 保守コスト増加         | {{低/中/高}} | {{低/中/高}} | {{対策}} |

---

## 整合性維持戦略

### データベース層での対策

```sql
-- CHECK制約の例
ALTER TABLE orders
ADD CONSTRAINT chk_total_calculation
CHECK (total = subtotal + tax);

-- トリガーの例（必要な場合）
CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
  NEW.total := NEW.subtotal + NEW.tax;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_order_total
BEFORE INSERT OR UPDATE ON orders
FOR EACH ROW EXECUTE FUNCTION update_order_total();
```

### アプリケーション層での対策

```typescript
// サービス層での整合性維持
class OrderService {
  async updateOrder(id: string, data: UpdateOrderInput) {
    // 計算済みフィールドを自動更新
    const total = data.subtotal + data.tax;

    return this.orderRepository.update(id, {
      ...data,
      total,
    });
  }
}
```

### 監視・検証

- [ ] 定期的な整合性チェックジョブ
- [ ] 不整合検出時のアラート設定
- [ ] 修復手順の文書化

---

## 実装計画

### マイグレーション手順

1. [ ] 新規カラムの追加（NULL許可）
2. [ ] 既存データの更新（計算値の設定）
3. [ ] NOT NULL制約の追加
4. [ ] CHECK制約の追加
5. [ ] アプリケーション層の更新
6. [ ] トリガー/関数の追加（必要な場合）

### ロールバック手順

```sql
-- ロールバック用マイグレーション
ALTER TABLE orders DROP CONSTRAINT IF EXISTS chk_total_calculation;
ALTER TABLE orders DROP COLUMN IF EXISTS total;
```

---

## 承認

| 役割               | 名前     | 承認日   | 署名 |
| ------------------ | -------- | -------- | ---- |
| テックリード       | {{名前}} | {{日付}} | ☐    |
| DBA                | {{名前}} | {{日付}} | ☐    |
| プロダクトオーナー | {{名前}} | {{日付}} | ☐    |

---

## レビュー履歴

| 日付     | レビュアー | コメント     |
| -------- | ---------- | ------------ |
| {{日付}} | {{名前}}   | {{コメント}} |

---

## 関連ドキュメント

- [ ] パフォーマンステスト結果
- [ ] スキーマ変更PR
- [ ] 監視設定変更
