# クエリ最適化チェックリスト

## 基本情報

| 項目           | 内容                               |
| -------------- | ---------------------------------- |
| **日付**       | {{YYYY-MM-DD}}                     |
| **分析者**     | {{名前}}                           |
| **対象クエリ** | {{クエリ概要}}                     |
| **問題症状**   | {{レスポンス遅延、タイムアウト等}} |

---

## 1. 現状分析

### 1.1 クエリ情報

```sql
-- 対象クエリ
{{クエリ}}
```

### 1.2 実行計画

```sql
EXPLAIN QUERY PLAN
{{クエリ}}
```

```
-- 実行計画の結果を貼り付け
{{実行計画}}
```

### 1.3 パフォーマンス指標

| 指標     | 現在値 | 目標値 |
| -------- | ------ | ------ |
| 実行時間 | {{ms}} | {{ms}} |
| 返却行数 | {{行}} | -      |

---

## 2. 問題パターンの特定

### 2.1 スキャンタイプ

- [ ] **SCAN TABLE**: テーブル全体スキャン
  - 該当テーブル: {{テーブル名}}
  - 推定行数: {{行数}}

- [ ] **SEARCH TABLE**: インデックス使用（OK）

- [ ] **USING COVERING INDEX**: カバリングインデックス（最適）

### 2.2 JOINアルゴリズム

SQLiteは主にNested Loop Joinを使用

- [ ] **両テーブルでSCAN TABLE**: 非効率
  - 外側テーブル: {{テーブル名}}
  - 内側テーブル: {{テーブル名}}

- [ ] **片方でSEARCH TABLE**: 改善の余地あり

- [ ] **両方でSEARCH TABLE**: 最適（OK）

### 2.3 その他の問題

- [ ] **AUTOMATIC INDEX**: 一時インデックス発生
  - 対象: {{ORDER BY / GROUP BY}}
  - 永続インデックス追加を検討

- [ ] **複数テーブルスキャン**: JOIN条件にインデックスなし
  - 対象テーブル: {{テーブル名}}

---

## 3. N+1問題チェック

### 3.1 コード確認

- [ ] ループ内でDBクエリを実行していないか
- [ ] リレーションデータを個別に取得していないか
- [ ] `with`オプションを使用しているか

### 3.2 N+1パターン検出

```typescript
// 問題のあるコード
{{N+1コードの例}}
```

### 3.3 解決策

- [ ] Eager Loading（with）を使用
- [ ] Manual JOINを使用
- [ ] INクエリ（バッチ取得）を使用

---

## 4. インデックス分析

### 4.1 現在のインデックス

```sql
SELECT name, sql
FROM sqlite_master
WHERE type = 'index' AND tbl_name = '{{テーブル名}}';
```

| インデックス名     | カラム     | 使用されているか |
| ------------------ | ---------- | ---------------- |
| {{インデックス名}} | {{カラム}} | ☐ Yes / ☐ No     |

### 4.2 インデックス追加候補

| カラム     | 理由          | 優先度   |
| ---------- | ------------- | -------- |
| {{カラム}} | WHERE句で使用 | 高/中/低 |

### 4.3 追加インデックスSQL

```sql
-- 推奨インデックス
CREATE INDEX {{インデックス名}} ON {{テーブル}}({{カラム}});
```

---

## 5. クエリ改善案

### 5.1 SELECT句の最適化

- [ ] 必要なカラムのみ選択しているか
- [ ] `SELECT *`を使用していないか

```sql
-- Before
SELECT * FROM orders ...

-- After
SELECT id, status, created_at FROM orders ...
```

### 5.2 WHERE句の最適化

- [ ] インデックスが効く条件になっているか
- [ ] 関数でカラムをラップしていないか

```sql
-- Before（インデックス効かない）
WHERE LOWER(email) = 'test@example.com'

-- After（インデックス効く）
WHERE email = 'test@example.com'
```

### 5.3 JOIN最適化

- [ ] 適切なJOIN順序になっているか
- [ ] 不要なJOINがないか

### 5.4 ページネーション最適化

- [ ] OFFSET使用を避けているか
- [ ] カーソルベースになっているか

```sql
-- Before（遅い）
SELECT * FROM orders ORDER BY created_at LIMIT 20 OFFSET 10000;

-- After（速い）
SELECT * FROM orders
WHERE created_at < {{cursor}}
ORDER BY created_at DESC LIMIT 20;
```

---

## 6. 改善後の検証

### 6.1 改善後クエリ

```sql
{{改善後のクエリ}}
```

### 6.2 改善後の実行計画

```
{{改善後の実行計画}}
```

### 6.3 パフォーマンス比較

| 指標     | Before | After  | 改善率 |
| -------- | ------ | ------ | ------ |
| 実行時間 | {{ms}} | {{ms}} | {{%}}  |

---

## 7. 追加対策

### 7.1 統計情報の更新

```sql
ANALYZE {{テーブル名}};
```

### 7.2 SQLite最適化

```sql
-- インデックスの再構築
REINDEX {{インデックス名}};

-- データベースの最適化
VACUUM;

-- 統計情報の更新
ANALYZE;
```

### 7.3 キャッシュ戦略

- [ ] アプリケーションキャッシュの導入検討
- [ ] クエリ結果のキャッシング検討

---

## 8. 結論

### 8.1 実施した改善

1. {{改善1}}
2. {{改善2}}
3. {{改善3}}

### 8.2 残課題

1. {{課題1}}
2. {{課題2}}

### 8.3 監視項目

- [ ] 実行時間の継続監視
- [ ] インデックス使用率の確認
- [ ] データ量増加時の再評価

---

## 9. 承認

| 役割       | 名前     | 承認日   |
| ---------- | -------- | -------- |
| 分析者     | {{名前}} | {{日付}} |
| レビュアー | {{名前}} | {{日付}} |
