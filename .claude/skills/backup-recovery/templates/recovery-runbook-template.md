# 復旧ランブック

## 文書情報

| 項目 | 内容 |
|------|------|
| 対象システム | [システム名] |
| 作成日 | YYYY-MM-DD |
| 最終テスト | YYYY-MM-DD |
| 次回テスト予定 | YYYY-MM-DD |
| 担当者 | [担当者名] |

## クイックリファレンス

### 緊急連絡先

| 役割 | 名前 | 連絡先 | 対応時間 |
|------|------|--------|---------|
| プライマリオンコール | [名前] | [電話/Slack] | 24/7 |
| セカンダリオンコール | [名前] | [電話/Slack] | 24/7 |
| DBA | [名前] | [電話/Slack] | 営業時間 |
| 技術リード | [名前] | [電話/Slack] | 営業時間 |
| CTO（エスカレーション） | [名前] | [電話/Slack] | 緊急時のみ |

### 重要な接続情報

```yaml
# 本番環境
production:
  database_url: ${DATABASE_URL}
  neon_project_id: [プロジェクトID]
  region: [リージョン]

# バックアップ
backup:
  location: [バックアップ場所]
  access: [アクセス方法]
```

---

## シナリオ1: 行単位の誤削除

### 概要
- **影響度**: 低〜中
- **想定復旧時間**: 15分〜1時間
- **必要権限**: データベース読み書き権限

### 前提条件
- [ ] 削除されたレコードのIDまたは条件が特定できている
- [ ] 削除時刻が概ね特定できている
- [ ] PITRが有効である

### 手順

#### Step 1: 影響評価（5分）

```sql
-- 削除されたレコード数の推定
-- アプリケーションログから情報を収集
```

確認事項:
- [ ] 影響を受けるレコード数
- [ ] 関連テーブルへの影響
- [ ] ビジネスへの影響度

#### Step 2: 復旧ブランチ作成（5分）

```bash
# Neonの場合
neon branches create \
  --name recovery_$(date +%Y%m%d_%H%M%S) \
  --from main@[削除前の時刻]

# 接続情報を取得
neon connection-string --branch [ブランチ名]
```

#### Step 3: データ抽出（10分）

```sql
-- 復旧ブランチに接続して抽出
\c [復旧ブランチ接続文字列]

-- 削除されたデータを確認
SELECT * FROM [テーブル名] WHERE [条件];

-- CSVにエクスポート（必要に応じて）
\copy (SELECT * FROM [テーブル名] WHERE [条件]) TO '/tmp/recovery_data.csv' CSV HEADER;
```

#### Step 4: 本番への復元（10分）

```sql
-- 本番に接続
\c [本番接続文字列]

-- データを挿入
INSERT INTO [テーブル名] (column1, column2, ...)
VALUES (...);

-- または外部キー制約を一時的に無効化して挿入
BEGIN;
SET CONSTRAINTS ALL DEFERRED;
INSERT INTO [テーブル名] SELECT * FROM ...;
COMMIT;
```

#### Step 5: 検証（5分）

```sql
-- 復元されたデータを確認
SELECT * FROM [テーブル名] WHERE [条件];

-- レコード数を確認
SELECT COUNT(*) FROM [テーブル名] WHERE [条件];
```

### 完了チェックリスト
- [ ] データが正しく復元された
- [ ] アプリケーションが正常動作している
- [ ] 関連データの整合性が保たれている
- [ ] 復旧ブランチを削除（または保持期間を設定）
- [ ] インシデントレポートを作成

---

## シナリオ2: テーブル復旧

### 概要
- **影響度**: 中〜高
- **想定復旧時間**: 30分〜2時間
- **必要権限**: データベース管理者権限

### 前提条件
- [ ] 影響を受けるテーブルが特定できている
- [ ] 復旧時点が決定している
- [ ] アプリケーションへの影響が評価されている

### 手順

#### Step 1: 影響隔離（即座）

```sql
-- アプリケーションからのアクセスを制限
-- オプション1: テーブルへのアクセス権を一時的に削除
REVOKE ALL ON [テーブル名] FROM [アプリケーションロール];

-- オプション2: メンテナンスモードを有効化
-- （アプリケーション側の対応が必要）
```

関係者への通知:
- [ ] 技術リードに報告
- [ ] 影響を受けるチームに通知
- [ ] 必要に応じてステータスページを更新

#### Step 2: 復旧ブランチ作成（10分）

```bash
# 障害発生前の時点からブランチ作成
neon branches create \
  --name recovery_table_$(date +%Y%m%d) \
  --from main@[復旧時点]
```

#### Step 3: テーブルデータのエクスポート（15分）

```bash
# 復旧ブランチからテーブルをエクスポート
pg_dump \
  -h [復旧ブランチホスト] \
  -U [ユーザー] \
  -d [データベース] \
  -t [テーブル名] \
  --data-only \
  -f /tmp/table_backup.sql
```

#### Step 4: 本番への復元（30分）

```sql
-- 本番に接続
\c [本番接続文字列]

-- 既存データをバックアップ（念のため）
CREATE TABLE [テーブル名]_backup AS SELECT * FROM [テーブル名];

-- トランケートして復元
BEGIN;
TRUNCATE [テーブル名] CASCADE;
\i /tmp/table_backup.sql
COMMIT;
```

#### Step 5: 整合性確認（15分）

```sql
-- レコード数確認
SELECT COUNT(*) FROM [テーブル名];

-- 外部キー整合性確認
SELECT * FROM [テーブル名] t
LEFT JOIN [関連テーブル] r ON t.related_id = r.id
WHERE r.id IS NULL;

-- 重要なデータの確認
SELECT * FROM [テーブル名] WHERE [重要条件] LIMIT 10;
```

#### Step 6: アクセス復旧（5分）

```sql
-- アクセス権を復旧
GRANT ALL ON [テーブル名] TO [アプリケーションロール];
```

### 完了チェックリスト
- [ ] テーブルデータが完全に復元された
- [ ] 外部キー整合性が保たれている
- [ ] アプリケーションが正常動作している
- [ ] アクセス権が復旧している
- [ ] バックアップテーブルを削除（7日後）
- [ ] インシデントレポートを作成

---

## シナリオ3: フル復旧

### 概要
- **影響度**: 重大
- **想定復旧時間**: 2〜8時間
- **必要権限**: インフラ管理者権限

### 前提条件
- [ ] 障害の原因が特定または隔離されている
- [ ] 復旧時点が決定している
- [ ] 経営層への報告が完了している

### 手順

#### Step 1: 障害宣言（即座）

```markdown
## 障害通知

**発生日時**: [日時]
**影響**: データベース全体が利用不能
**現在の状態**: 復旧作業中
**次回更新**: [30分後の時刻]

対応者: [担当者名]
```

通知先:
- [ ] Slackの障害チャンネル
- [ ] ステータスページ
- [ ] 関係者へのメール

#### Step 2: 復旧ポイントの決定（15分）

```bash
# 利用可能なバックアップを確認
neon branches list --show-timestamps

# 最適な復旧ポイントを選択
# 考慮事項:
# - データ損失の最小化
# - 障害発生前であること
# - 整合性が保たれている時点
```

#### Step 3: 新環境の作成（30分）

```bash
# 指定時点から新しいブランチを作成
neon branches create \
  --name production_restored \
  --from main@[復旧時点]

# 接続情報を取得
neon connection-string --branch production_restored
```

#### Step 4: データ検証（60分）

```sql
-- 新環境に接続
\c [新環境接続文字列]

-- 全テーブルのレコード数確認
SELECT schemaname, relname, n_live_tup
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC;

-- クリティカルデータの確認
SELECT COUNT(*) FROM users;
SELECT COUNT(*) FROM orders WHERE created_at > '[復旧時点]';
SELECT COUNT(*) FROM transactions;

-- サンプルデータの目視確認
SELECT * FROM users ORDER BY created_at DESC LIMIT 10;
```

#### Step 5: アプリケーション切り替え（30分）

```bash
# 環境変数の更新
export DATABASE_URL="[新環境接続文字列]"

# アプリケーションの再起動
# （デプロイ方法によって異なる）

# ヘルスチェック
curl https://[アプリURL]/health
```

#### Step 6: 最終検証（30分）

```yaml
verification_checklist:
  - [ ] ログイン機能が動作する
  - [ ] 主要APIが応答する
  - [ ] データが正しく表示される
  - [ ] 新規データが保存できる
  - [ ] エラーログに異常がない
```

### 完了チェックリスト
- [ ] データベースが完全に復旧した
- [ ] アプリケーションが正常動作している
- [ ] ユーザーがサービスを利用できる
- [ ] 監視が正常に機能している
- [ ] 障害復旧を宣言した
- [ ] インシデントレポートを作成

---

## 事後対応

### インシデントレポートテンプレート

```markdown
# インシデントレポート

## 概要
- **発生日時**: YYYY-MM-DD HH:MM
- **復旧完了**: YYYY-MM-DD HH:MM
- **影響時間**: X時間Y分
- **影響範囲**: [影響を受けたサービス/ユーザー数]

## タイムライン
| 時刻 | イベント |
|------|---------|
| HH:MM | 障害検出 |
| HH:MM | 対応開始 |
| HH:MM | 復旧完了 |

## 根本原因
[根本原因の説明]

## 対応内容
[実施した対応の詳細]

## データ影響
- 損失データ: [あり/なし]
- RPO達成: [はい/いいえ]
- RTO達成: [はい/いいえ]

## 再発防止策
1. [対策1]
2. [対策2]
3. [対策3]

## 担当者
- 対応者: [名前]
- レビュー者: [名前]
```

---

## 付録

### よくある問題と対処法

| 問題 | 対処法 |
|------|--------|
| 接続できない | 接続文字列、ファイアウォール、VPNを確認 |
| 権限エラー | 適切なロールでログインしているか確認 |
| ディスク容量不足 | 不要なブランチ/バックアップを削除 |
| 復旧に時間がかかる | 並列処理、増分復旧を検討 |

### 関連ドキュメント
- [バックアップポリシー](./backup-policy-template.md)
- [DR計画](../resources/disaster-recovery-planning.md)
- [RPO/RTO設計](../resources/rpo-rto-design.md)
