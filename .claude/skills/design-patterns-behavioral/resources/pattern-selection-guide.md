# パターン選択ガイド

## 概要

このガイドは、行動パターンの選択を支援するための判断基準とフローチャートを提供します。

## 判断フローチャート

```
問題の特定
    │
    ▼
┌───────────────────────────────────────────┐
│ Q1: アルゴリズムを実行時に切り替える必要がある？ │
└───────────────────────────────────────────┘
    │
    ├─ Yes ──▶ Strategy Pattern
    │
    └─ No
        │
        ▼
┌───────────────────────────────────────────┐
│ Q2: 共通の処理フローがあり、一部のみ変動する？ │
└───────────────────────────────────────────┘
    │
    ├─ Yes ──▶ Template Method Pattern
    │
    └─ No
        │
        ▼
┌───────────────────────────────────────────┐
│ Q3: 操作の履歴管理・取り消しが必要？        │
└───────────────────────────────────────────┘
    │
    ├─ Yes ──▶ Command Pattern
    │
    └─ No
        │
        ▼
┌───────────────────────────────────────────┐
│ Q4: 複数の処理者がリクエストを処理する可能性？ │
└───────────────────────────────────────────┘
    │
    ├─ Yes ──▶ Chain of Responsibility Pattern
    │
    └─ No
        │
        ▼
┌───────────────────────────────────────────┐
│ Q5: 状態変化を複数のオブジェクトに通知する？  │
└───────────────────────────────────────────┘
    │
    ├─ Yes ──▶ Observer Pattern
    │
    └─ No
        │
        ▼
┌───────────────────────────────────────────┐
│ Q6: オブジェクトの振る舞いが状態に依存する？  │
└───────────────────────────────────────────┘
    │
    ├─ Yes ──▶ State Pattern
    │
    └─ No ──▶ 他のパターンを検討
```

## パターン比較マトリックス

| 観点   | Strategy         | Template Method | Command        | Chain        | Observer | State        |
| ------ | ---------------- | --------------- | -------------- | ------------ | -------- | ------------ |
| 目的   | アルゴリズム切替 | 共通フロー      | 操作カプセル化 | 処理チェーン | 状態通知 | 状態依存動作 |
| 構造   | 委譲             | 継承            | 委譲           | 委譲         | 委譲     | 委譲         |
| 柔軟性 | 高               | 中              | 高             | 高           | 高       | 高           |
| 複雑性 | 低               | 低              | 中             | 中           | 中       | 中           |
| Undo   | -                | -               | ✓              | -            | -        | -            |

## ワークフローエンジンでのパターン適用

### 推奨パターンの組み合わせ

```
IWorkflowExecutor (Strategy)
    │
    ├── BaseWorkflowExecutor (Template Method)
    │       │
    │       ├── 共通フロー定義
    │       └── フックポイント提供
    │
    ├── WorkflowRegistry (Registry)
    │       │
    │       └── Executorの動的管理
    │
    ├── WorkflowState (State)
    │       │
    │       └── PENDING → PROCESSING → COMPLETED/FAILED
    │
    ├── WorkflowObservable (Observer)
    │       │
    │       └── 状態変化の通知
    │
    └── ValidationChain (Chain of Responsibility)
            │
            └── 入力バリデーション
```

### 各パターンの役割

| パターン        | 役割                       | 適用箇所               |
| --------------- | -------------------------- | ---------------------- |
| Strategy        | ワークフロー実装の切り替え | IWorkflowExecutor      |
| Template Method | 共通実行フローの定義       | BaseWorkflowExecutor   |
| State           | ワークフロー状態管理       | WorkflowStatus         |
| Observer        | 状態変化の通知             | ログ、メトリクス、通知 |
| Chain           | バリデーションパイプライン | 入力検証               |
| Command         | 操作履歴（将来拡張）       | Undo/Redo              |

## パターン選択の判断基準

### Strategy Pattern を選ぶべき時

- [ ] 同じ目的を達成する複数のアルゴリズムがある
- [ ] 実行時にアルゴリズムを選択・切り替えする
- [ ] アルゴリズムの詳細をクライアントから隠蔽したい
- [ ] if-else/switchでアルゴリズムを選択している

### Template Method Pattern を選ぶべき時

- [ ] 複数のクラスに共通のアルゴリズム構造がある
- [ ] アルゴリズムの一部のみが異なる
- [ ] 共通処理を一箇所に集約したい
- [ ] 処理の順序を固定したい

### Command Pattern を選ぶべき時

- [ ] 操作の履歴管理が必要
- [ ] Undo/Redo機能が必要
- [ ] 操作のキューイングやスケジューリングが必要
- [ ] 操作のログ記録が必要

### Chain of Responsibility を選ぶべき時

- [ ] 複数のオブジェクトがリクエストを処理する可能性
- [ ] 処理者を動的に決定したい
- [ ] パイプライン処理が必要
- [ ] ミドルウェアパターンを実装したい

### Observer Pattern を選ぶべき時

- [ ] オブジェクトの状態変化を他に通知したい
- [ ] 通知先を動的に追加・削除したい
- [ ] イベント駆動アーキテクチャを実現したい
- [ ] 疎結合な通信が必要

### State Pattern を選ぶべき時

- [ ] オブジェクトの振る舞いが状態に依存する
- [ ] 状態遷移のロジックが複雑
- [ ] if-else/switchが状態判定で多用されている
- [ ] 状態を明示的に管理したい

## アンチパターン

### 過剰適用

- 単純な問題に複数のパターンを適用
- パターンのためのパターン適用
- 将来の拡張のための先行実装

### 不適切な選択

- StrategyとStateの混同
- Template MethodとStrategyの混同
- 単一責任原則の違反

## 段階的適用のガイドライン

### Phase 1: 最小限の実装

1. まずif-elseやswitchで実装
2. 問題の本質を理解

### Phase 2: パターン適用の検討

1. 重複や複雑性の発見
2. 適切なパターンの選択
3. リファクタリング

### Phase 3: パターンの組み合わせ

1. 単一パターンの限界を認識
2. 補完的なパターンの選択
3. 統合テスト
