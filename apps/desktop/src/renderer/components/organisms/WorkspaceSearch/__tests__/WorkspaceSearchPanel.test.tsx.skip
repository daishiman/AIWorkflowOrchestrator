import { describe, it, expect, beforeEach, vi } from "vitest";
import {
  render,
  screen,
  fireEvent,
  waitFor,
  within,
} from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { axe, toHaveNoViolations } from "jest-axe";
import { WorkspaceSearchPanel } from "../WorkspaceSearchPanel";

expect.extend(toHaveNoViolations);

// Mock IPC
const mockInvoke = vi.fn();
const mockOn = vi.fn();
vi.mock("@/hooks/useIpc", () => ({
  useIpc: () => ({ invoke: mockInvoke, on: mockOn }),
}));

describe("WorkspaceSearchPanel", () => {
  const user = userEvent.setup();

  const defaultProps = {
    workspacePath: "/workspace/project",
    onClose: vi.fn(),
    onFileSelect: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
    mockInvoke.mockResolvedValue({
      files: [],
      totalMatches: 0,
      searchTime: 0,
    });
  });

  describe("レンダリング", () => {
    it("should render search input field", () => {
      render(<WorkspaceSearchPanel {...defaultProps} />);

      expect(screen.getByRole("searchbox")).toBeInTheDocument();
      expect(
        screen.getByPlaceholderText(/ワークスペース.*検索|search.*workspace/i),
      ).toBeInTheDocument();
    });

    it("should render include/exclude pattern inputs", () => {
      render(<WorkspaceSearchPanel {...defaultProps} />);

      expect(screen.getByLabelText(/含める|include|対象/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/除外|exclude/i)).toBeInTheDocument();
    });

    it("should render search options toggles", () => {
      render(<WorkspaceSearchPanel {...defaultProps} />);

      expect(
        screen.getByRole("checkbox", {
          name: /大文字.*小文字|case.*sensitive/i,
        }),
      ).toBeInTheDocument();
      expect(
        screen.getByRole("checkbox", { name: /単語.*単位|whole.*word/i }),
      ).toBeInTheDocument();
      expect(
        screen.getByRole("checkbox", { name: /正規表現|regex/i }),
      ).toBeInTheDocument();
    });

    it("should render results tree container", () => {
      render(<WorkspaceSearchPanel {...defaultProps} />);

      expect(
        screen.getByRole("tree", { hidden: true }) ||
          screen.getByTestId("search-results-tree"),
      ).toBeInTheDocument();
    });
  });

  describe("検索実行", () => {
    it("should trigger search on Enter key press", async () => {
      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "findme{enter}");

      expect(mockInvoke).toHaveBeenCalledWith(
        "search:workspace:execute",
        expect.objectContaining({
          query: "findme",
          workspacePath: "/workspace/project",
        }),
      );
    });

    it("should include filter patterns in search request", async () => {
      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      const includeInput = screen.getByLabelText(/含める|include|対象/i);
      const excludeInput = screen.getByLabelText(/除外|exclude/i);

      await user.type(includeInput, "**/*.ts");
      await user.type(excludeInput, "node_modules/**");
      await user.type(searchInput, "test{enter}");

      expect(mockInvoke).toHaveBeenCalledWith(
        "search:workspace:execute",
        expect.objectContaining({
          include: ["**/*.ts"],
          exclude: ["node_modules/**"],
        }),
      );
    });

    it("should debounce search input", async () => {
      vi.useFakeTimers();
      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "t");
      await user.type(searchInput, "e");
      await user.type(searchInput, "s");
      await user.type(searchInput, "t");

      expect(mockInvoke).not.toHaveBeenCalled();

      vi.advanceTimersByTime(300);

      expect(mockInvoke).toHaveBeenCalledTimes(1);
      vi.useRealTimers();
    });
  });

  describe("検索結果表示", () => {
    const mockResults = {
      files: [
        {
          path: "/workspace/project/src/index.ts",
          matches: [
            { line: 10, column: 5, text: "const test = 1;", length: 4 },
            { line: 20, column: 10, text: "function test() {}", length: 4 },
          ],
        },
        {
          path: "/workspace/project/src/utils.ts",
          matches: [
            { line: 5, column: 1, text: "export const test = 2;", length: 4 },
          ],
        },
      ],
      totalMatches: 3,
      searchTime: 150,
    };

    it("should display results grouped by file", async () => {
      mockInvoke.mockResolvedValue(mockResults);

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/index\.ts/)).toBeInTheDocument();
        expect(screen.getByText(/utils\.ts/)).toBeInTheDocument();
      });
    });

    it("should display match count per file", async () => {
      mockInvoke.mockResolvedValue(mockResults);

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        // index.ts has 2 matches
        expect(screen.getByText(/2/)).toBeInTheDocument();
      });
    });

    it("should display total results count and search time", async () => {
      mockInvoke.mockResolvedValue(mockResults);

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/3.*件|3.*results/i)).toBeInTheDocument();
        expect(screen.getByText(/150.*ms/i)).toBeInTheDocument();
      });
    });

    it("should show 'no results' message when nothing found", async () => {
      mockInvoke.mockResolvedValue({
        files: [],
        totalMatches: 0,
        searchTime: 50,
      });

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "notfound{enter}");

      await waitFor(() => {
        expect(
          screen.getByText(/結果.*なし|no.*results|見つかり/i),
        ).toBeInTheDocument();
      });
    });

    it("should expand/collapse file groups", async () => {
      mockInvoke.mockResolvedValue(mockResults);

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/index\.ts/)).toBeInTheDocument();
      });

      // Click to expand
      const fileHeader = screen.getByText(/index\.ts/).closest("button");
      if (fileHeader) {
        await user.click(fileHeader);
      }

      // Match lines should be visible
      expect(screen.getByText(/const test = 1/)).toBeInTheDocument();
    });
  });

  describe("ファイルナビゲーション", () => {
    const mockResults = {
      files: [
        {
          path: "/workspace/project/src/index.ts",
          matches: [
            { line: 10, column: 5, text: "const test = 1;", length: 4 },
          ],
        },
      ],
      totalMatches: 1,
      searchTime: 50,
    };

    it("should navigate to file on match click", async () => {
      mockInvoke.mockResolvedValue(mockResults);

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/index\.ts/)).toBeInTheDocument();
      });

      // Expand and click match
      const fileHeader = screen.getByText(/index\.ts/).closest("button");
      if (fileHeader) {
        await user.click(fileHeader);
      }

      const matchLine = screen.getByText(/const test = 1/);
      await user.click(matchLine);

      expect(defaultProps.onFileSelect).toHaveBeenCalledWith(
        "/workspace/project/src/index.ts",
        expect.objectContaining({ line: 10, column: 5 }),
      );
    });

    it("should open file on double-click of file header", async () => {
      mockInvoke.mockResolvedValue(mockResults);

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/index\.ts/)).toBeInTheDocument();
      });

      const fileHeader = screen.getByText(/index\.ts/);
      await user.dblClick(fileHeader);

      expect(defaultProps.onFileSelect).toHaveBeenCalledWith(
        "/workspace/project/src/index.ts",
        expect.any(Object),
      );
    });
  });

  describe("プログレス表示", () => {
    it("should show progress during search", async () => {
      let resolveSearch: (value: unknown) => void;
      mockInvoke.mockImplementation(
        () =>
          new Promise((resolve) => {
            resolveSearch = resolve;
          }),
      );

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      expect(screen.getByRole("progressbar")).toBeInTheDocument();

      resolveSearch!({ files: [], totalMatches: 0, searchTime: 0 });

      await waitFor(() => {
        expect(screen.queryByRole("progressbar")).not.toBeInTheDocument();
      });
    });

    it("should show files as they are found (streaming)", async () => {
      // Simulate progress updates
      const progressHandler = vi.fn();
      mockOn.mockImplementation((event: string, handler: Function) => {
        if (event === "search:workspace:progress") {
          progressHandler.mockImplementation(handler);
        }
        return () => {};
      });

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      // Simulate progress event
      progressHandler({
        filesSearched: 10,
        totalFiles: 100,
        currentFile: "src/index.ts",
      });

      await waitFor(() => {
        expect(screen.getByText(/10.*\/.*100|10%/)).toBeInTheDocument();
      });
    });
  });

  describe("キャンセル", () => {
    it("should cancel search on button click", async () => {
      mockInvoke.mockImplementation(
        () => new Promise((resolve) => setTimeout(resolve, 10000)),
      );

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      const cancelButton = screen.getByRole("button", {
        name: /キャンセル|cancel|停止/i,
      });
      await user.click(cancelButton);

      expect(mockInvoke).toHaveBeenCalledWith("search:workspace:cancel");
    });

    it("should cancel search on Escape key", async () => {
      mockInvoke.mockImplementation(
        () => new Promise((resolve) => setTimeout(resolve, 10000)),
      );

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await user.keyboard("{Escape}");

      expect(mockInvoke).toHaveBeenCalledWith("search:workspace:cancel");
    });
  });

  describe("キーボードナビゲーション", () => {
    const mockResults = {
      files: [
        {
          path: "/workspace/project/src/index.ts",
          matches: [{ line: 10, column: 5, text: "test1", length: 4 }],
        },
        {
          path: "/workspace/project/src/utils.ts",
          matches: [{ line: 5, column: 1, text: "test2", length: 4 }],
        },
      ],
      totalMatches: 2,
      searchTime: 50,
    };

    it("should navigate results with arrow keys", async () => {
      mockInvoke.mockResolvedValue(mockResults);

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/index\.ts/)).toBeInTheDocument();
      });

      // Navigate down
      await user.keyboard("{ArrowDown}");
      await user.keyboard("{ArrowDown}");

      // Should have focus on result item
      const activeElement = document.activeElement;
      expect(activeElement?.getAttribute("role")).toBe("treeitem");
    });

    it("should open file on Enter key", async () => {
      mockInvoke.mockResolvedValue(mockResults);

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/index\.ts/)).toBeInTheDocument();
      });

      // Navigate to first result and press Enter
      await user.keyboard("{ArrowDown}");
      await user.keyboard("{Enter}");

      expect(defaultProps.onFileSelect).toHaveBeenCalled();
    });
  });

  describe("仮想スクロール", () => {
    it("should render large result sets with virtualization", async () => {
      const manyFiles = Array.from({ length: 1000 }, (_, i) => ({
        path: `/workspace/project/file${i}.ts`,
        matches: [{ line: 1, column: 1, text: "test", length: 4 }],
      }));

      mockInvoke.mockResolvedValue({
        files: manyFiles,
        totalMatches: 1000,
        searchTime: 500,
      });

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/1000.*件|1000.*results/i)).toBeInTheDocument();
      });

      // Should not render all 1000 items at once
      const allFileItems = screen.getAllByRole("treeitem", { hidden: true });
      expect(allFileItems.length).toBeLessThan(100);
    });
  });

  describe("アクセシビリティ", () => {
    it("should have no accessibility violations", async () => {
      const { container } = render(<WorkspaceSearchPanel {...defaultProps} />);

      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });

    it("should have proper ARIA attributes for tree structure", async () => {
      mockInvoke.mockResolvedValue({
        files: [
          {
            path: "/workspace/project/src/index.ts",
            matches: [{ line: 10, column: 5, text: "test", length: 4 }],
          },
        ],
        totalMatches: 1,
        searchTime: 50,
      });

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        const tree = screen.getByRole("tree");
        expect(tree).toHaveAttribute("aria-label");
      });
    });

    it("should announce result count to screen readers", async () => {
      mockInvoke.mockResolvedValue({
        files: [
          {
            path: "/workspace/project/src/index.ts",
            matches: [{ line: 10, column: 5, text: "test", length: 4 }],
          },
        ],
        totalMatches: 1,
        searchTime: 50,
      });

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        const liveRegion = screen.getByRole("status");
        expect(liveRegion).toBeInTheDocument();
        expect(liveRegion).toHaveTextContent(/1/);
      });
    });
  });

  describe("エラーハンドリング", () => {
    it("should display error message on search failure", async () => {
      mockInvoke.mockRejectedValue(new Error("Search failed"));

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/エラー|error|failed/i)).toBeInTheDocument();
      });
    });

    it("should allow retry after error", async () => {
      mockInvoke.mockRejectedValueOnce(new Error("Search failed"));
      mockInvoke.mockResolvedValueOnce({
        files: [],
        totalMatches: 0,
        searchTime: 0,
      });

      render(<WorkspaceSearchPanel {...defaultProps} />);

      const searchInput = screen.getByRole("searchbox");
      await user.type(searchInput, "test{enter}");

      await waitFor(() => {
        expect(screen.getByText(/エラー|error/i)).toBeInTheDocument();
      });

      // Retry
      await user.clear(searchInput);
      await user.type(searchInput, "test2{enter}");

      await waitFor(() => {
        expect(screen.queryByText(/エラー|error/i)).not.toBeInTheDocument();
      });
    });
  });

  describe("フィルターの保存", () => {
    it("should remember include/exclude patterns", async () => {
      const { rerender } = render(<WorkspaceSearchPanel {...defaultProps} />);

      const includeInput = screen.getByLabelText(/含める|include|対象/i);
      await user.type(includeInput, "**/*.tsx");

      // Remount component
      rerender(<WorkspaceSearchPanel {...defaultProps} />);

      expect(screen.getByLabelText(/含める|include|対象/i)).toHaveValue(
        "**/*.tsx",
      );
    });
  });
});
