# タスク：コマンド・エージェント・スキル選定ドキュメント作成

## 📋 目的
ユーザーから与えられた**複雑なタスク内容**を、単一責務の原則に基づいて**複数のサブタスク**に分解し、各サブタスクに最適なコマンド・エージェント・スキルの組み合わせを選定して、構造化ドキュメントとして記録する。

## 🎯 このドキュメントの本質
このプロンプトは**エージェントへの橋渡し役**であり、以下を提供します：
1. **ユーザー指示の保持** - 元の指示を正確に保存（最重要）
2. **フェーズ構造の定義** - Phase 0→6の必須フロー
3. **TDD原則の強制** - Red→Green→Refactorの厳守
4. **抽象的な概念** - 具体的判断は各エージェントに委任
5. **品質基準の設定** - 必須ゲートの定義

**重要**: このドキュメント自体は**コードを作成しません**。タスク整理と方針提示のみ行います。

## 🎯 成果物
- **ファイル名**: `docs/30-workflows/[機能名]/command-agent-skill.md`
- **内容**: タスク分解結果と、各サブタスクに対する最適なコマンド・エージェント・スキルの組み合わせを記載した構造化ドキュメント

## 📚 参照ファイル
以下の3つのファイルから情報を取得すること：
1. `.claude/agents/agent_list.md` - 全エージェントの定義
2. `.claude/commands/command_list.md` - 全コマンドの定義
3. `.claude/slills/skill_list.md` - 全スキルの定義

## 🔧 実行手順

### ステップ1: タスク全体の分析
ユーザーから提供されたタスク内容を以下の観点で分析する：
- **最終ゴール**（何を達成するのか）
- **必要な成果物**（何を作成・修正するのか）
- **技術スタック**（使用する技術、フレームワーク）
- **制約条件**（期限、品質基準、セキュリティ要件等）

### ステップ2: タスクの分解
タスクを**単一責務の原則**に基づいて、複数のサブタスクに分解する。

#### 必須フェーズ構造（この順序を厳守）
すべてのタスクは以下のフェーズ構造に従って分解すること：

1. **Phase 0: 要件定義（必須）**
   - 何を作るのか、なぜ作るのかを明文化
   - 受け入れ基準（Acceptance Criteria）の定義
   - 成果物: `docs/00-requirements/[機能名]-requirements.md`

2. **Phase 1: 設計**
   - アーキテクチャ設計、API設計、DB設計等
   - 成果物: 設計ドキュメント、ER図、API仕様書

3. **Phase 2: テスト作成（TDD: Red）**
   - 実装前にテストを先に作成
   - テストが失敗することを確認（Red状態）
   - 成果物: テストコード（failing tests）

4. **Phase 3: 実装（TDD: Green）**
   - テストを通すための最小限の実装
   - テストが成功することを確認（Green状態）
   - 成果物: 実装コード（passing tests）

5. **Phase 4: リファクタリング（TDD: Refactor）**
   - コード品質の改善
   - テストが引き続き通ることを確認
   - 成果物: リファクタリング済みコード

6. **Phase 5: 品質保証**
   - 全テスト実行（ユニット、E2E）
   - Lint、型チェック、セキュリティ監査
   - 成果物: テストレポート、品質レポート

7. **Phase 6: PR作成・マージ**
   - プルリクエスト作成
   - レビュー対応
   - マージ

#### 分解基準
1. **フェーズ単位**（必須構造）：上記の必須フェーズ構造に従う
2. **レイヤー単位**：フロントエンド、バックエンド、データベース、インフラ
3. **機能単位**：認証、API、UI、データ処理
4. **役割単位**：各エージェントの専門領域に対応

#### 分解時の注意点
- **要件定義は必ず最初**に実行すること（Phase 0）
- **TDDサイクル（Red-Green-Refactor）を厳守**すること
- 各サブタスクは**独立して実行可能**であること
- サブタスク間の**依存関係**を明確にする
- 各サブタスクの**成果物**が明確であること
- 1サブタスク = 1コマンド の対応を原則とする
- **実装前に必ずテストを作成**すること

### ステップ3: 各サブタスクへのコマンド選定
各サブタスクに対して、`command_list.md`から**最適な1つ**のコマンドを選定する：

#### 選定基準
- サブタスクの**目的**とコマンドの**目的**が一致
- コマンドの**成果物**がサブタスクの要求と一致
- コマンドの**使用エージェント**がサブタスクの必要スキルを持つ

### ステップ4: エージェントとスキルの紐付け
各コマンドに対して：
1. 実際に起動する**エージェント**を`agent_list.md`から特定（複数可）
2. 各エージェントが活用する**スキル**を`skill_list.md`から抽出
3. エージェント間の**実行順序**を定義

### ステップ5: 依存関係の整理
サブタスク間の依存関係を整理する：
- **順次実行**：前のサブタスクの完了が必要
- **並列実行可能**：独立して実行できる
- **条件付き実行**：特定条件下でのみ実行

### ステップ6: ドキュメント作成
以下のテンプレートに従って、**単一のMarkdownファイル**を作成する。

## 📄 ドキュメントテンプレート

```markdown
# [機能名] - コマンド・エージェント・スキル選定

## ユーザーからの元の指示
```
[ユーザーが提供した元の指示文をそのまま記載]
※この内容が全ての基準となる。タスク分解やエージェント選定は、
  この元の指示を正確に実現するために行う。
```

## タスク概要
[元の指示から抽出した概要を簡潔に記載]

### 最終ゴール（抽象）
[タスクで達成すべき最終的な目標を抽象的に記載]

### 最終成果物（抽象的分類）
- **機能成果物**: [機能的な成果物の種類]
- **ドキュメント成果物**: [ドキュメントの種類]
- **品質成果物**: [テスト・品質レポート等]

---

## タスク分解サマリー

| サブタスクID | フェーズ | サブタスク名 | コマンド分類 | 求められる専門性 | TDD | 依存関係 |
|------------|---------|------------|------------|----------------|-----|---------|
| T-00 | Phase 0 | 要件定義 | 要件分析系 | 要件工学 | - | なし |
| T-01 | Phase 1 | 設計 | 設計系 | アーキテクチャ/モデリング | - | T-00 |
| T-02 | Phase 2 | テスト作成 | テスト生成系 | TDD/テスト設計 | Red | T-01 |
| T-03 | Phase 3 | 実装 | 実装系 | コーディング/ロジック | Green | T-02 |
| T-04 | Phase 4 | リファクタリング | 品質改善系 | リファクタリング | Refactor | T-03 |
| T-05 | Phase 5 | 品質保証 | 検証系 | QA/セキュリティ | - | T-04 |
| T-06 | Phase 6 | PR作成 | Git操作系 | バージョン管理 | - | T-05 |

**総サブタスク数**: [数]個
**総コマンド数**: [数]個
**総エージェント数**: [数]個（重複除く）
**TDDサイクル**: Phase 2→3→4で完結

---

## 全体実行フロー

```mermaid
graph TD
    Start[タスク開始] --> T00[T-00: 要件定義<br/>Phase 0]
    T00 --> T01[T-01: 設計<br/>Phase 1]
    T01 --> T02[T-02: テスト作成<br/>Phase 2: Red]
    T02 --> T03[T-03: 実装<br/>Phase 3: Green]
    T03 --> T04[T-04: リファクタリング<br/>Phase 4: Refactor]
    T04 --> T05[T-05: 品質保証<br/>Phase 5]
    T05 --> T06[T-06: PR作成・マージ<br/>Phase 6]
    T06 --> End[タスク完了]

    style T00 fill:#e3f2fd
    style T01 fill:#e1f5ff
    style T02 fill:#fff3e0
    style T03 fill:#fff3e0
    style T04 fill:#ffecb3
    style T05 fill:#f1f8e9
    style T06 fill:#c8e6c9
```

**凡例**:
- 🔵 Phase 0: 要件定義（必須開始点）
- 💠 Phase 1: 設計
- 🔴 Phase 2: TDD Red（テスト失敗確認）
- 🟢 Phase 3: TDD Green（テスト成功確認）
- 🟡 Phase 4: TDD Refactor（品質改善）
- ✅ Phase 5: 品質保証（全テスト・監査）
- 📋 Phase 6: PR・マージ（最終工程）

---

## サブタスク詳細

### T-00: 要件定義（Phase 0 - 必須開始点）

#### 目的
タスクの目的、スコープ、受け入れ基準を明文化する

#### 選定アプローチ
- **コマンド選定**: 要件定義に特化したコマンドを選ぶ
- **エージェント選定**: 要件分析の専門性を持つエージェントを選ぶ
- **実行タイプ**: 順次（すべてのタスクの起点）
- **依存関係**: なし（必ず最初に実行）

#### 抽象的実行概念

##### 概念1: 要件の抽出と構造化
**求められる専門性**: 要件工学、ユースケース分析
- **実行内容の概念**:
  - タスクの背景と目的を理解する
  - 達成すべきゴールを明確にする
  - 検証可能な基準を定義する
- **入力の抽象**: ユーザーの要望・問題記述
- **出力の抽象**: 構造化された要件仕様

**必要なスキル領域**:
- 要件定義手法
- 受け入れ基準の記述
- ユースケースモデリング

#### 成果物の抽象的定義
- **要件ドキュメント**（場所: docs/00-requirements/配下）
  - 何を作るのか（What）
  - なぜ作るのか（Why）
  - どう検証するのか（How to verify）

#### 単一責務確認
- [ ] 要件の明確化のみに専念している
- [ ] 設計・実装の詳細には踏み込んでいない
- [ ] 検証可能な基準が定義されている

---

### T-01: 設計（Phase 1 - 構造定義）

#### 目的（抽象）
システム構造、データモデル、インターフェース等を定義する

#### 選定アプローチ
- **コマンド選定**: 設計領域（architecture/api/database/ui等）に特化したコマンド
- **エージェント選定**: 該当領域の設計専門性を持つエージェント
- **実行タイプ**: 順次または並列（設計対象が独立している場合）
- **依存関係**: T-00（要件定義）完了後

#### 抽象的実行概念
**求められる専門性**: システム設計、アーキテクチャパターン、モデリング
- **実行内容の概念**:
  - 要件を実現可能な構造に落とし込む
  - コンポーネント間の関係性を定義する
  - データフロー・制御フローを設計する

**必要なスキル領域**:
- アーキテクチャ設計手法
- 設計パターン
- モデリング技術

#### 成果物の抽象的定義
- **設計ドキュメント**（形式: 図・仕様書・スキーマ定義等）
  - 構造の全体像
  - コンポーネント間の関係
  - インターフェース定義

---

### T-02: テスト作成（Phase 2: TDD Red - 検証基準定義）

#### 目的（抽象）
期待される動作を検証するテストを実装より先に作成する

#### 選定アプローチ
- **コマンド選定**: テスト生成・作成に特化したコマンド
- **エージェント選定**: TDD・テスト設計の専門性を持つエージェント
- **実行タイプ**: 順次
- **依存関係**: T-01（設計）完了後

#### 抽象的実行概念
**求められる専門性**: TDD、テスト設計、品質保証
- **実行内容の概念**:
  - 受け入れ基準をテストコードに変換する
  - 正常系・異常系・境界値をカバーする
  - テストを実行してRed（失敗）を確認する

**必要なスキル領域**:
- テスト駆動開発（TDD）
- テストケース設計
- 境界値分析

#### 検証の抽象的概念
テストを実行し、**実装がないため失敗する**ことを確認する（これが正しい状態）

#### 成果物の抽象的定義
- **テストコード**: 期待される動作の定義、エッジケースの検証
- **Red状態の証跡**: テストが適切に失敗することの確認

#### エージェントへの委任事項
- 具体的なテストフレームワークの選択
- テストファイルの配置場所
- テストケースの具体的な記述

---

### T-03: 実装（Phase 3: TDD Green - 最小実装）

#### 目的（抽象）
テストを通すための最小限の実装を行う

#### 選定アプローチ
- **コマンド選定**: 実装に特化したコマンド（対象領域に応じて）
- **エージェント選定**: 該当領域の実装専門性を持つエージェント
- **実行タイプ**: 順次
- **依存関係**: T-02（テスト作成）完了後

#### 抽象的実行概念
**求められる専門性**: コーディング、ビジネスロジック、技術実装
**原則**: テストを通すための最小限、過剰な機能追加の回避

#### 検証の抽象的概念
テストを実行し、**すべて成功する**ことを確認する（Red→Greenの遷移）

#### エージェントへの委任事項
- 具体的な実装手法の選択
- コードの配置場所
- 使用するライブラリ・フレームワーク

---

### T-04: リファクタリング（Phase 4: TDD Refactor - 品質向上）

#### 目的（抽象）
動作を変えずにコード品質を改善する

#### 選定アプローチ
- **コマンド選定**: リファクタリング・品質改善に特化したコマンド
- **エージェント選定**: コード品質・リファクタリングの専門性を持つエージェント
- **実行タイプ**: 順次
- **依存関係**: T-03（実装）完了後

#### 抽象的実行概念
**求められる専門性**: リファクタリング技術、コード品質管理
**原則**: DRY、SOLID、複雑度の低減

#### 検証の抽象的概念
テストを再実行し、**依然として成功する**ことを確認する（動作の不変性保証）

#### エージェントへの委任事項
- 具体的なリファクタリング手法
- 改善の優先順位
- コード品質メトリクスの目標値

---

### T-05: 品質保証（Phase 5: 必須ゲート - 完成基準検証）

#### 目的（抽象）
定義された品質基準をすべて満たすことを検証する

#### 選定アプローチ
- **コマンド選定**: 包括的テスト・品質検証コマンド
- **エージェント選定**: QA・セキュリティ監査の専門性を持つエージェント
- **実行タイプ**: 順次（すべての検証を実施）
- **依存関係**: T-04（リファクタリング）完了後

#### 抽象的検証概念
**検証する品質次元**:
1. 機能的正しさ
2. コード品質
3. 型安全性
4. テスト網羅性
5. セキュリティ

#### 品質ゲート通過条件（抽象）
すべての基準を満たさない限り、次のPhaseに進んではいけない

#### エージェントへの委任事項
- 具体的な品質基準値の設定
- 使用する検証ツールの選択
- セキュリティ監査の範囲

---

### T-06: PR作成・マージ（Phase 6: 最終工程 - 正式完了）

#### 目的（抽象）
変更を正式にメインブランチに統合する

#### 選定アプローチ
- **コマンド選定**: PR作成・Git操作に特化したコマンド
- **エージェント選定**: バージョン管理の専門性を持つエージェント
- **実行タイプ**: 順次
- **依存関係**: T-05（品質保証）完了後

#### 抽象的実行概念
**求められる専門性**: バージョン管理、ドキュメンテーション
**原則**: 品質ゲート通過後のみ実行、適切なレビュープロセス

#### エージェントへの委任事項
- コミットメッセージの形式
- PRの説明内容
- レビュー体制

---

## エージェント活用マトリクス（抽象的分類）

| 専門領域 | Phase 0 | Phase 1 | Phase 2 | Phase 3 | Phase 4 | Phase 5 | Phase 6 | 主要スキル領域 |
|---------|---------|---------|---------|---------|---------|---------|---------|--------------|
| 要件分析系 | ✅ | - | - | - | - | - | - | 要件工学、ユースケース |
| 設計系 | - | ✅ | - | - | - | - | - | アーキテクチャ、モデリング |
| テスト系 | - | - | ✅ | - | - | ✅ | - | TDD、品質保証 |
| 実装系 | - | - | - | ✅ | - | - | - | コーディング、ロジック |
| 品質系 | - | - | - | - | ✅ | ✅ | - | リファクタリング、静的解析 |
| セキュリティ系 | - | - | - | - | - | ✅ | - | 脆弱性診断、監査 |
| Git操作系 | - | - | - | - | - | - | ✅ | バージョン管理 |

**凡例**: ✅ = 該当Phaseで活用、- = 不使用

**注**: 具体的なエージェント名ではなく、**専門領域**でマッピングすること

---

## スキル活用サマリー

### 最頻出スキル Top 5
1. **[スキル名]** - [使用回数]回（[エージェント名]で使用）
2. **[スキル名]** - [使用回数]回
3. **[スキル名]** - [使用回数]回

### カテゴリ別スキル分布
- **フロントエンド**: [数]個
- **バックエンド**: [数]個
- **データベース**: [数]個
- **テスト**: [数]個
- **セキュリティ**: [数]個

---

## 実行推奨順序（抽象的フロー）

### Phase 0: 要件定義（必須開始点）
**概念**: 何を作るかを明確にする
**エージェントへの橋渡し情報**:
- 元のユーザー指示を正確に理解する
- 要件定義に特化したコマンドを選定する
- 検証可能な受け入れ基準を作成する

**期待される成果**: 要件ドキュメント、受け入れ基準

### Phase 1: 設計（構造定義）
**概念**: どう作るかを設計する
**エージェントへの橋渡し情報**:
- 要件を実現可能な構造に変換する
- 設計領域（architecture/api/database/ui等）を特定する
- 該当領域の設計コマンド・エージェントを選定する

**期待される成果**: 設計ドキュメント、スキーマ、仕様書

### Phase 2: テスト作成（TDD Red - 検証基準）
**概念**: 期待される動作をテストで表現する
**エージェントへの橋渡し情報**:
- 実装より**先**にテストを作成する
- 受け入れ基準をテストコードに変換する
- テスト実行でRed（失敗）を確認する

**期待される成果**: テストコード（failing tests）、Red状態の証跡

### Phase 3: 実装（TDD Green - 最小実装）
**概念**: テストを通すための実装を行う
**エージェントへの橋渡し情報**:
- テストを通すための**最小限**のコードを書く
- 過剰な機能追加を避ける
- テスト実行でGreen（成功）を確認する

**期待される成果**: 実装コード、Green状態の証跡（Red→Green遷移）

### Phase 4: リファクタリング（TDD Refactor - 品質向上）
**概念**: 動作を変えずにコード品質を改善する
**エージェントへの橋渡し情報**:
- 可読性・保守性を向上させる
- テストが引き続き通ることを確認する
- 品質改善のコマンド・エージェントを選定する

**期待される成果**: リファクタリング済みコード、継続Green状態の証跡

### Phase 5: 品質保証（必須ゲート - 完成検証）
**概念**: すべての品質基準を満たすことを検証する
**エージェントへの橋渡し情報**:
- 包括的なテスト実行コマンドを選定する
- 品質検証（Lint/型チェック）コマンドを選定する
- セキュリティ監査の必要性を判断する
- **すべての基準をクリアするまで次へ進まない**

**品質ゲート基準**（すべて必須）:
- 機能検証: 自動テストの完全成功
- コード品質: 静的解析ツールのクリア
- 型安全性: 型システムの整合性
- 網羅性: テストカバレッジの達成
- セキュリティ: 重大な脆弱性の不在

**期待される成果**: テストレポート、品質レポート、セキュリティ監査結果

### Phase 6: PR作成・マージ（最終工程 - 正式完了）
**概念**: 変更を正式に統合する
**エージェントへの橋渡し情報**:
- 品質ゲート通過後のみ実行する
- PR作成コマンドを選定する
- 適切なPR説明を作成する

**期待される成果**: プルリクエスト、マージ完了

---

## 期待される最終成果物

### 主要成果物
- `[ファイルパス]` - [説明]
- `[ファイルパス]` - [説明]

### 副次的成果物
- `[ファイルパス]` - [説明]

### ドキュメント
- `[ファイルパス]` - [説明]

---

## 品質保証チェックリスト

### アーキテクチャ整合性
- [ ] クリーンアーキテクチャの原則に準拠している
- [ ] レイヤー間の依存関係が正しい方向（外→内）である
- [ ] 循環参照が発生していない

### 単一責務の原則
- [ ] 各サブタスクが1つの明確な責務を持つ
- [ ] 各エージェントが1つの専門領域に特化している
- [ ] スキルの適用が適切である

### 依存関係
- [ ] サブタスク間の依存関係が明確である
- [ ] 不要な依存関係がない
- [ ] 並列実行可能なタスクが特定されている

### 完全性
- [ ] すべての必要なサブタスクが含まれている
- [ ] 各サブタスクの成果物が定義されている
- [ ] 最終ゴールを達成できる構成になっている

---

## リスクと対策

### 想定リスク
| リスク | 影響度 | 対策サブタスク |
|--------|--------|--------------|
| [リスク内容] | 高/中/低 | T-XX |

### 前提条件
- [前提条件1]
- [前提条件2]

---

## 備考

### 技術的制約
- [制約1]
- [制約2]

### 推奨実行環境
- [環境1]
- [環境2]

### 参考資料
- [資料1]
- [資料2]
```

## ⚠️ 制約条件

### ドキュメント作成の制約
1. **ファイル作成のみ実行**すること（タスクの実際の実行は行わない）
2. **1つのMarkdownファイル**にすべての情報をまとめること
3. **既存ファイルの編集・削除は行わない**こと
4. ドキュメントは**docs/30-workflows/[機能名]/ディレクトリ**に配置すること
5. `[機能名]`はタスク内容から適切な名前を付けること（kebab-case推奨）
6. **ユーザーからの元の指示文を必ず含める**こと（最優先事項）

### タスク分解の制約
7. 各サブタスクは**必ず1つのコマンド分類**に対応させること
8. **複雑なタスクほど細かく分解**すること（目安：最小3個〜最大10サブタスク）
9. **Phase 0（要件定義）は必須**（省略不可）
10. **TDDサイクル（Phase 2→3→4）は必須**（省略不可）
11. **品質ゲート（Phase 5）は必須**（省略不可）

### 抽象化レベルの制約
12. **具体的なコマンド名を記述しない**（例: `/gather-requirements`ではなく「要件定義コマンド」）
13. **具体的なエージェント名を記述しない**（例: `@req-analyst`ではなく「要件分析専門エージェント」）
14. **具体的な数値を固定しない**（例: 「80%」ではなく「十分な網羅性」）
15. **原則と概念で記述する**（How toではなくWhatとWhyを重視）
16. **ソースコード例を記述しない**（エージェントが作成する）
17. **技術選択を固定しない**（エージェントが判断する）

### コンテンツの制約
18. **実装コードは一切記述しない**（エージェントに委任）
19. **具体的なファイルパスは最小限**（構造のみ示す）
20. **抽象的な概念と橋渡し情報のみ**記述する

## ✅ 完了条件
以下がすべて満たされたら完了とする：

### ドキュメント作成の完了条件
- [ ] `docs/30-workflows/[機能名]/command-agent-skill.md`が作成されている
- [ ] **ユーザーからの元の指示文**が冒頭に記載されている（最重要）
- [ ] タスクが**適切に分解**されている（各サブタスクが単一責務）
- [ ] 各サブタスクに**1つのコマンド分類**が選定されている（具体名ではなく）
- [ ] すべてのエージェント領域がフェーズごとに記載されている（具体名ではなく専門性）
- [ ] 各フェーズの活用スキル領域が記載されている
- [ ] サブタスク間の**依存関係**が明確である
- [ ] **実行フロー図**が作成されている
- [ ] 単一責務の原則が確認されている
- [ ] **具体的なコード例が含まれていない**ことを確認

### 必須フェーズの組み込み確認
- [ ] **Phase 0（要件定義）**が必ず含まれている
- [ ] **Phase 2（TDD: Red）**でテスト作成が計画されている
- [ ] **Phase 3（TDD: Green）**で実装が計画されている
- [ ] **Phase 4（TDD: Refactor）**でリファクタリングが計画されている
- [ ] **Phase 5（品質保証）**で全テスト・Lint・型チェックが計画されている
- [ ] **Phase 6（PR作成）**でPR作成・マージが計画されている

### TDDサイクルの確認
- [ ] テスト作成が実装より**先**に計画されている
- [ ] テスト失敗確認（Red）のステップが含まれている
- [ ] テスト成功確認（Green）のステップが含まれている
- [ ] リファクタリング後のテスト再実行が含まれている

### 品質ゲートの確認
- [ ] 品質ゲート通過条件が明記されている
- [ ] すべてのテスト実行が計画されている
- [ ] Lint・型チェックが計画されている
- [ ] セキュリティ監査が必要に応じて計画されている

## 🚫 実行してはいけないこと

### ドキュメント作成に関する禁止事項
- **ユーザーからの元の指示文を欠落させる**（最重要禁止事項）
- **タスクの実際の実行**（コード生成、ファイル編集等）
- **ソースコードの記述**（サンプルコード、実装例等）
- **具体的なコマンド名・エージェント名の記述**
- 複数ファイルへの分割
- docs/30-workflows/以外のディレクトリへの配置
- 参照ファイル（agent_list.md等）の編集
- 1つのサブタスクに複数のコマンドを割り当てる
- サブタスクの分解を怠る（すべてを1コマンドで実行しようとする）

### 必須フェーズ・TDDに関する禁止事項
- **Phase 0（要件定義）をスキップする** - 必ず最初に実行すること
- **テストより先に実装する** - Phase 2（テスト）→ Phase 3（実装）の順序を守る
- **テストの実行・確認をスキップする** - 各Phaseで必ず検証すること
- **品質ゲートをスキップする** - Phase 5の全チェックを必ず実行
- **品質ゲート未通過でPRを作成する** - すべての基準を満たしてからPhase 6へ
- **TDDサイクルを逆転させる** - Red→Green→Refactorの順序を厳守

### 抽象度に関する禁止事項
- **具体的すぎる記述** - 特定の実装詳細に固執しない（抽象的な概念で記述）
- **フレームワーク依存の記述** - 技術選択の柔軟性を保つ
- **AIの思考を制限する記述** - AIが状況に応じて最適な選択ができる余地を残す

---

## 📝 タスクタイプ別アプローチ

### タスクタイプの分類
ユーザーから与えられるタスクは以下のような多様なタイプが想定されます。各タイプに応じて、必須フェーズ構造を適切に適用してください。

#### 1. 新規機能実装
- **特徴**: ゼロから新しい機能を作成
- **フェーズ適用**: Phase 0→1→2→3→4→5→6 すべて実行
- **重点**: 要件定義とTDDサイクルの完全な実施

#### 2. バグ修正
- **特徴**: 既存機能の不具合を修正
- **フェーズ適用**: Phase 0（バグ調査・再現手順）→2（再現テスト）→3（修正）→4→5→6
- **重点**: バグを再現するテストの作成（Red）→ 修正（Green）

#### 3. リファクタリング
- **特徴**: 既存コードの品質改善（動作は変えない）
- **フェーズ適用**: Phase 0（改善方針）→2（既存動作のテスト確保）→4（リファクタリング）→5→6
- **重点**: テストが通り続けることを確認しながら改善

#### 4. パフォーマンス最適化
- **特徴**: 既存機能の速度・効率改善
- **フェーズ適用**: Phase 0（計測・ボトルネック特定）→2（パフォーマンステスト）→3（最適化）→4→5→6
- **重点**: 計測可能な改善目標の設定

#### 5. セキュリティ強化
- **特徴**: 脆弱性対策・セキュリティ改善
- **フェーズ適用**: Phase 0（脆弱性調査）→2（セキュリティテスト）→3（対策実装）→5（監査）→6
- **重点**: セキュリティ監査とコンプライアンス確認

#### 6. ドキュメント作成・更新
- **特徴**: 技術文書、API仕様書等の作成
- **フェーズ適用**: Phase 0（ドキュメント要件）→1（構造設計）→3（執筆）→5（レビュー）→6
- **重点**: 読み手を意識した明確な構造化

### 抽象的フェーズ適用の原則
具体的なタスク内容によらず、以下の**抽象的な原則**を守ってください：

1. **必ず要件を明確にしてから始める**（Phase 0）
2. **実装より先にテストを書く**（Phase 2 → Phase 3）
3. **テストが通ることを確認してから次に進む**
4. **品質を検証してから完了とする**（Phase 5）
5. **PRを通して正式に完了させる**（Phase 6）

---

## 📝 タスク分解の例

### 悪い例（分解不足）
```
タスク: ユーザー認証機能の実装
→ サブタスク1つだけ: /full-feature-development user-authentication
```
**問題点**: 単一責務の原則に反している。複数の関心事が混在。TDDサイクルなし。

### 良い例（新規機能実装：TDD完全適用）
```
タスク: ユーザー認証機能の実装

→ T-00: [要件定義コマンド] - 認証要件の整理（Phase 0）
   専門性: 要件工学
   成果物: 要件定義書

→ T-01: [API設計コマンド] - 認証エンドポイント設計（Phase 1）
   専門性: API設計、セキュリティ
   成果物: API仕様書

→ T-02: [テスト生成コマンド] - 認証テスト作成（Phase 2: Red）
   専門性: TDD、テスト設計
   検証: テスト失敗を確認

→ T-03: [認証実装コマンド] - OAuth実装（Phase 3: Green）
   専門性: 認証・認可、セキュリティ
   検証: テスト成功を確認

→ T-04: [リファクタリングコマンド] - コード品質改善（Phase 4: Refactor）
   専門性: コード品質、リファクタリング
   検証: テスト継続成功を確認

→ T-05: [品質保証コマンド] - 全品質基準検証（Phase 5）
   専門性: QA、セキュリティ監査
   品質ゲート: すべての基準をクリア

→ T-06: [PR作成コマンド] - PR作成・マージ（Phase 6）
   専門性: バージョン管理
   最終確認: 品質ゲート通過済み
```
**利点**（抽象的）:
- 必須フェーズ構造を完全に適用
- TDDサイクルの厳守
- 品質基準の明確な検証
- 正式な完了プロセス

### 良い例（バグ修正：再現テスト重視）
```
タスク: ログイン時のエラー修正

→ T-00: [バグ調査コマンド] - 原因特定（Phase 0）
   専門性: デバッグ、根本原因分析
   成果物: バグ調査レポート

→ T-01: [テスト生成コマンド] - バグ再現テスト（Phase 2: Red）
   専門性: TDD
   検証: バグが再現され、テスト失敗を確認

→ T-02: [実装コマンド] - バグ修正（Phase 3: Green）
   専門性: 該当領域の実装知識
   検証: 再現テストが成功を確認

→ T-03: [リファクタリングコマンド] - 関連コード改善（Phase 4）
   専門性: リファクタリング
   検証: すべてのテストが成功を確認

→ T-04: [品質保証コマンド] - 全テスト・品質検証（Phase 5）
   専門性: QA
   品質ゲート: 回帰テスト含めクリア

→ T-05: [PR作成コマンド] - PR作成（Phase 6）
   専門性: バージョン管理
```
**利点**（抽象的）:
- バグ再現テストの確実な作成
- 修正の検証可能性
- 回帰防止の保証

### 良い例（リファクタリング：品質改善）
```
タスク: レガシーコードのリファクタリング

→ T-00: [分析コマンド] - 改善方針定義（Phase 0）
   専門性: コード分析、技術的負債評価
   成果物: リファクタリング計画書

→ T-01: [テスト生成コマンド] - 既存動作のテスト確保（Phase 2）
   専門性: TDD、レガシーコードテスト
   検証: 現在の動作を捕捉

→ T-02: [リファクタリングコマンド] - コード改善（Phase 4）
   専門性: リファクタリング技術
   検証: テストが通り続けることを確認

→ T-03: [品質保証コマンド] - 品質検証（Phase 5）
   専門性: QA、静的解析
   品質ゲート: すべての基準をクリア

→ T-04: [PR作成コマンド] - PR作成（Phase 6）
```
**利点**（抽象的）:
- 既存動作を壊さない保証
- 段階的な改善
- 品質の客観的検証

---

## 🚀 実行開始の合図

ユーザーが**具体的なタスク内容**を提供した時点で、以下の流れでドキュメント作成を開始してください：

### 実行フロー
1. **ユーザーの元の指示を保存**する（最優先）
2. **タスク内容を理解**する（ステップ1）
3. **タスクタイプを特定**する（新規機能/バグ修正/リファクタリング等）
4. **必須フェーズ構造を適用**してサブタスクに分解する（ステップ2）
5. **各サブタスクにコマンド分類を選定**する（ステップ3）
6. **エージェント専門性とスキル領域を紐付ける**（ステップ4）
7. **依存関係を整理**する（ステップ5）
8. **テンプレートに従ってドキュメントを作成**する（ステップ6）

### 確認事項（開始前に必ず確認）
- [ ] ユーザーからの元の指示文を保持しているか？（最重要）
- [ ] Phase 0（要件定義）が含まれているか？
- [ ] TDDサイクル（Phase 2→3→4）が含まれているか？
- [ ] 品質ゲート（Phase 5）が含まれているか？
- [ ] PR作成（Phase 6）が含まれているか？
- [ ] 各サブタスクが単一責務になっているか？
- [ ] 具体的なコード例を記述していないか？

### 開始宣言の例
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 ユーザーからの元の指示（保存完了）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[ユーザーが提供した元のタスク内容をそのまま保存]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

→ ステップ1: タスク分析
   - タスクタイプ: [新規機能/バグ修正/リファクタリング/パフォーマンス最適化等]
   - 最終ゴール（抽象）: [達成すべき目標]
   - 技術領域: [フロントエンド/バックエンド/データベース/インフラ等]

→ ステップ2: フェーズ構造適用
   - 必須Phase: Phase 0→1→2→3→4→5→6
   - タスクタイプに応じた調整: [調整内容]
   - 推定サブタスク数: [数]個

→ ステップ3: 抽象的コマンド・エージェント選定
   - 各Phaseに求められる専門性領域を特定
   - コマンド分類から候補カテゴリを選定
   - エージェントの専門領域とマッピング

→ ステップ4〜6: 詳細化とドキュメント作成
   - スキル領域の抽出（具体名ではなく領域）
   - 依存関係の整理
   - テンプレートへの記入（抽象的な概念のみ）

→ docs/30-workflows/[機能名]/command-agent-skill.md 作成開始...

※ 具体的なコマンド実行・コード作成は行いません
※ エージェントへの橋渡し情報のみを記述します
```

---

## 📌 重要な注意事項

### 🎯 このドキュメントの役割（明確化）
このドキュメントは**コード作成ではなく、タスク整理とエージェントへの橋渡し**のためのものです：

#### ✅ このドキュメントで行うこと
- タスクの分解と構造化
- 必要なコマンド・エージェント・スキルの「分類」特定
- フェーズ構造の適用
- 依存関係の整理
- **ユーザーからの元の指示の保持**（最重要）

#### ❌ このドキュメントで行わないこと
- **具体的なソースコードの作成**
- **具体的な実装の詳細記述**
- **特定のコマンド・エージェントへの固定**
- **数値目標の決定**（エージェントが判断）
- **技術選択の決定**（エージェントが判断）

### 🔑 ユーザー指示の最重要性
**ユーザーからの元の指示文**がすべての基準です：
- 必ずドキュメントに元の指示を記載する
- タスク分解は元の指示を正確に実現するために行う
- エージェントは元の指示を最優先で参照する
- 元の指示が欠落すると、意図がずれるリスクがある

### TDD（テスト駆動開発）の徹底
**TDDは任意ではなく必須**です。以下の原則を厳守：
1. 実装より先にテストを作成
2. Red（失敗）を確認
3. Green（成功）を確認
4. Refactor（改善）してもGreenを維持

### 品質ゲートの必須化
Phase 5の品質ゲートは**すべてのタスクで必須**です。
以下のすべてを満たさない限り、Phase 6に進んではいけません：
- 機能検証の完全成功
- コード品質基準のクリア
- 型安全性の確認
- テストカバレッジの達成
- セキュリティ脆弱性の不在

### 要件定義の必須化
**Phase 0（要件定義）は絶対に省略不可**です：
- 「何を作るか」を明確にしてから始める
- 受け入れ基準を定義する
- 要件ドキュメントを作成する

### 抽象化レベルの維持
このドキュメントは**概念と原則のみ**を記述します：

#### ✅ 抽象的（推奨）
- 「要件定義に特化したコマンドを選ぶ」
- 「テスト設計の専門性を持つエージェント」
- 「品質基準をすべて満たす」

#### ❌ 具体的すぎる（避ける）
- 「`/gather-requirements`を実行する」
- 「`@req-analyst`を起動する」
- 「カバレッジ80%以上」
- 「Vitestを使う」
- コード例の記述

#### 抽象化の理由
1. **エージェントの自律性**: 状況に応じた最適な判断
2. **柔軟性**: 技術スタック・タスクタイプへの適応
3. **進化可能性**: 新規コマンド・エージェントへの対応
4. **創造性**: エージェントが専門知識を発揮できる余地

#### エージェントとの役割分担
| このドキュメント | 各エージェント |
|----------------|--------------|
| 概念・原則の提示 | 具体的な判断・実装 |
| フェーズ構造の定義 | コマンド・ツールの選択 |
| 抽象的な基準 | 具体的な数値目標 |
| タスクの分解 | 実際のコード作成 |
| 橋渡し情報 | 専門知識の発揮 |
