# パフォーマンスベンチマークスイート追加 - タスク指示書

## メタ情報

| 項目         | 内容                                   |
| ------------ | -------------------------------------- |
| タスクID     | CONV-ENHANCEMENT-001                   |
| タスク名     | パフォーマンスベンチマークスイート追加 |
| 分類         | 改善/品質向上                          |
| 対象機能     | 全コンバーター、ConversionService      |
| 優先度       | 低                                     |
| 見積もり規模 | 小規模（約2時間）                      |
| ステータス   | 未実施                                 |
| 発見元       | Phase 7 最終アーキテクチャレビュー     |
| 発見日       | 2025-12-25                             |

---

## 1. なぜこのタスクが必要か（Why）

### 1.1 背景

Phase 8の手動テストで簡易的なパフォーマンス計測を実施しましたが、体系的なベンチマークスイートは未整備です。

**レビュー指摘の原文**:

```
Phase 7 最終アーキテクチャレビュー - Minor Recommendation R2

推奨事項: パフォーマンスベンチマークの追加を検討
優先度: Low
工数: 2h
```

現状の計測は手動テスト7ケース（534ms総実行時間）のみで、ファイルサイズは小〜中規模（<1MB）に限られます。

### 1.2 問題点・課題

**問題1: パフォーマンス劣化の検出が困難**

コード変更（リファクタリング、機能追加）後のパフォーマンス影響が不明です。

**問題2: 最適化の優先順位が不明**

どのコンバーターを最適化すべきか判断できません。現状のボトルネックはMarkdownConverter（428ms）ですが、他のコンバーターの性能特性が不明です。

**問題3: 将来の拡張時の性能予測ができない**

新機能（AST解析、ストリーミング）追加時の性能影響が予測できません。

### 1.3 放置した場合の影響

**短期的影響**:

- パフォーマンス劣化の見逃し
- 最適化の機会損失

**長期的影響**:

- 性能問題の蓄積
- リファクタリング時のリグレッション

---

## 2. 何を達成するか（What）

### 2.1 目的

自動化されたパフォーマンスベンチマークスイートを構築し、コード変更時の性能影響を可視化する。

### 2.2 最終ゴール

- 自動ベンチマーク: CI/CD統合可能な自動実行スクリプト
- 多様なファイルサイズ: 1KB, 10KB, 100KB, 1MB
- コンバーター別計測: 各コンバーターの個別性能を計測
- メトリクス: 処理時間、メモリ使用量、スループット
- 可視化: 結果をMarkdown表形式で出力
- 履歴追跡: ベンチマーク結果の履歴管理（オプション）

### 2.3 スコープ

#### 含むもの

- ベンチマークスクリプト実装（benchmark.ts）
- テストデータ生成（1KB, 10KB, 100KB, 1MB × 3形式）
- 6コンバーター × 4サイズ = 24ベンチマーク実行
- 処理時間計測（平均、中央値、P95）
- メモリ使用量計測
- Markdown形式で結果出力

#### 含まないもの

- リアルタイムモニタリング
- プロファイリング（V8 profiler統合）
- 可視化ダッシュボード（Grafana等）
- 他のベンチマークツール統合（Benchmark.js等）

### 2.4 成果物

| 成果物                 | パス                                                                              | 内容                 |
| ---------------------- | --------------------------------------------------------------------------------- | -------------------- |
| ベンチマークスクリプト | `packages/shared/src/services/conversion/__manual-tests__/benchmark.ts`           | 自動ベンチマーク実行 |
| テストデータ生成       | `packages/shared/src/services/conversion/__manual-tests__/generate-test-files.ts` | テストファイル生成   |
| ベンチマーク結果       | `docs/30-workflows/rag-conversion-system/benchmark-results.md`                    | 最新ベンチマーク結果 |

---

## 3. どのように実行するか（How）

### 3.1 前提条件

- なし（独立タスク）

### 3.2 依存タスク

- なし（独立タスク）

### 3.3 必要な知識・スキル

- Node.js `perf_hooks` モジュール
- `process.memoryUsage()` API
- 統計計算（平均、中央値、パーセンタイル）

### 3.4 推奨アプローチ

段階的な実装：

1. まずテストデータ生成スクリプトを実装
2. 単一コンバーターでベンチマーク実装・検証
3. 全コンバーターに拡張
4. 結果のMarkdown出力実装
5. CI/CD統合はオプション（手動実行で十分）

---

## 4. 実行手順

### Phase構成

```
Phase 1: テストデータ生成スクリプト実装
Phase 2: ベンチマークスクリプト実装
Phase 3: 全コンバーターでベンチマーク実行
Phase 4: 結果のMarkdown出力実装
Phase 5: ベンチマーク実行・結果記録
```

### Phase 1: テストデータ生成スクリプト実装

#### Claude Code スラッシュコマンド

```
手動実装
```

#### 目的

各ファイル形式・サイズのテストファイルを生成

#### 成果物

generate-test-files.ts

#### 完了条件

- [ ] Markdown生成関数実装
- [ ] TypeScript生成関数実装
- [ ] YAML生成関数実装
- [ ] 1KB, 10KB, 100KB, 1MBの各サイズ生成可能

---

### Phase 2: ベンチマークスクリプト実装

#### 目的

処理時間とメモリ使用量を計測するベンチマーク関数を実装

#### 成果物

benchmark.ts

#### 完了条件

- [ ] benchmarkConverter()関数実装
- [ ] 処理時間計測（平均、中央値、P95）実装
- [ ] メモリ使用量計測実装

---

### Phase 3: 全コンバーターでベンチマーク実行

#### 目的

6コンバーター × 4サイズ = 24ベンチマークを実行

#### 完了条件

- [ ] 全24ベンチマーク実行成功
- [ ] 結果データ収集完了

---

### Phase 4: 結果のMarkdown出力実装

#### 目的

ベンチマーク結果を見やすい表形式で出力

#### 成果物

formatResults()関数

#### 完了条件

- [ ] 処理時間テーブル出力実装
- [ ] メモリ使用量テーブル出力実装
- [ ] スループットテーブル出力実装（オプション）

---

### Phase 5: ベンチマーク実行・結果記録

#### 目的

実際にベンチマークを実行し、結果をドキュメント化

#### 成果物

docs/30-workflows/rag-conversion-system/benchmark-results.md

#### 完了条件

- [ ] ベンチマーク実行成功
- [ ] 結果ファイル生成成功
- [ ] 実行環境情報記録（Node.jsバージョン、OS）

---

## 5. 完了条件チェックリスト

### 機能要件

- [ ] ベンチマークスクリプト実装済み
- [ ] 6コンバーター × 4サイズ = 24ベンチマーク実行成功
- [ ] 処理時間計測（平均、中央値、P95）
- [ ] メモリ使用量計測
- [ ] Markdown形式で結果出力
- [ ] 実行コマンド動作確認

### 品質要件

- [ ] TypeScriptエラー: 0
- [ ] ESLintエラー: 0
- [ ] ベンチマーク実行成功（全24完了）

### ドキュメント要件

- [ ] ベンチマーク結果レポート作成済み
- [ ] 実行方法ドキュメント化済み
- [ ] 結果の解釈ガイド追加済み

---

## 6. 検証方法

### テストケース

**ベンチマーク実行テスト（4ケース）**:

- 全6コンバーターが実行される
- 全4サイズ（1KB, 10KB, 100KB, 1MB）が実行される
- 24個のベンチマーク結果が出力される
- Markdown形式で結果が保存される

**メトリクス計測テスト（3ケース)**:

- 処理時間が計測される
- メモリ使用量が計測される
- スループットが計算される

### 検証手順

1. テストデータ生成: `pnpm tsx generate-test-files.ts`
2. ベンチマーク実行: `node --expose-gc benchmark.ts`
3. 結果ファイル確認: `cat benchmark-results.md`
4. 結果の妥当性確認（処理時間が非機能要件内）

---

## 7. リスクと対策

| リスク                   | 影響度 | 発生確率 | 対策                               |
| ------------------------ | ------ | -------- | ---------------------------------- |
| 環境依存の結果           | 中     | 高       | 実行環境情報を記録、相対比較を優先 |
| テストデータの代表性不足 | 中     | 中       | 実際のファイル形式に近いデータ生成 |
| CI実行時間の増加         | 低     | 高       | オプショナル実行、週次スケジュール |

---

## 8. 参照情報

### 関連ドキュメント

- [02-non-functional-requirements.md](../../00-requirements/02-non-functional-requirements.md) - 1.4 パフォーマンス要件
- [05-architecture.md](../../00-requirements/05-architecture.md) - 5.2A.9 パフォーマンス要件とベンチマーク

### 参考資料

- [Node.js perf_hooks](https://nodejs.org/api/perf_hooks.html)
- [Node.js process.memoryUsage()](https://nodejs.org/api/process.html#process_process_memoryusage)

---

## 9. 備考

### レビュー指摘の原文（該当する場合）

```
Phase 7 最終アーキテクチャレビュー - Minor Recommendations

R2: パフォーマンスベンチマークの追加を検討
優先度: Low
工数: 2h
```

### 補足事項

- ベンチマーク結果は絶対値ではなく、相対比較（前回実行比）を重視してください
- CI/CD統合はオプションです。手動実行で十分な価値が得られます
- `--expose-gc` フラグでガベージコレクションを制御すると、より正確なメモリ計測が可能です
